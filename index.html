<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scratch King - Promethean Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            background: #000;
            touch-action: none;
            position: fixed;
        }
        
        html {
            overflow: hidden;
            max-width: 100%;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #064b2f 0%, #053d26 100%);
        }

        /* Splash Screen */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #014421;
            z-index: 1000;
        }

        #splashScreen.hidden {
            display: none;
        }
        
        #splashLogo {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 500px;
            height: auto;
            opacity: 1;
        }
        
        #splashPlayBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 1s ease-in;
            padding: 20px 60px;
            font-size: 2.5em;
            font-weight: bold;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(209, 17, 17, 0.5);
            text-align: center;
            margin: 0;
            border: none;
            display: inline-block;
            max-width: 80vw;
            white-space: nowrap;
        }
        
        #splashPlayBtn.visible {
            opacity: 1;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.8), 0 0 40px rgba(209, 17, 17, 0.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.02);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9), 0 0 60px rgba(209, 17, 17, 0.8);
            }
        }
        
        @keyframes shimmer {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
                border-color: rgba(255, 215, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
                border-color: rgba(255, 215, 0, 0.8);
            }
        }
        
        #splashHowToPlay {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 1s ease-in 0.3s;
            color: #FFD700;
            font-size: 1.2em;
            text-decoration: underline;
            cursor: pointer;
            background: none;
            border: none;
            padding: 10px 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }
        
        #splashHowToPlay.visible {
            opacity: 1;
        }
        
        #splashHowToPlay:hover {
            color: #FFF;
            text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.5);
        }
        
        #splashSettingsBtn, #splashLeaderboardBtn {
            position: absolute;
            top: 15px;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            padding: 10px 18px;
            font-size: 1em;
            background: #014421;
            border: 2px solid #d11111;
            color: #d11111;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            max-width: 45vw;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        #splashSettingsBtn {
            left: 10px;
        }
        
        #splashLeaderboardBtn {
            right: 10px;
        }
        
        #splashSettingsBtn.visible, #splashLeaderboardBtn.visible {
            opacity: 1;
        }
        
        #splashSettingsBtn:hover, #splashLeaderboardBtn:hover {
            background: #d11111;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
        }
        
        #splashLeaderboardBtn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.5);
            border-color: #666;
            color: #888;
        }
        
        #splashLeaderboardBtn:disabled:hover {
            transform: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        
        #splashCopyright {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 1s ease-in;
            padding: 0 10px;
        }
        
        #splashCopyright.visible {
            opacity: 1;
        }
        
        /* Responsive adjustments for smaller screens */
        @media (max-width: 400px) {
            #splashSettingsBtn, #splashLeaderboardBtn {
                padding: 8px 12px;
                font-size: 0.9em;
                max-width: 42vw;
            }
            
            #splashLogo {
                width: 80%;
                max-width: 350px;
                top: 70px;
            }
            
            #splashPlayBtn {
                padding: 15px 40px;
                font-size: 2em;
                max-width: 85vw;
            }
            
            #splashHowToPlay {
                font-size: 1.1em;
                bottom: 70px;
            }
            
            #splashCopyright {
                font-size: 0.75em;
            }
        }
        
        @media (max-height: 600px) {
            #splashLogo {
                top: 50px;
                max-width: 400px;
            }
            
            #splashHowToPlay {
                bottom: 60px;
            }
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #014421;
            z-index: 10;
        }

        .overlay.active {
            display: flex;
        }


        /* Game Over Screen */
        #gameOver {
            text-align: center;
            padding: 20px;
            width: 100%;
            max-width: 600px;
        }

        .stats-table {
            width: 90%;
            max-width: 400px;
            margin: 15px auto;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #d11111;
            border-radius: 8px;
            overflow: hidden;
        }

        .stats-table tr {
            border-bottom: 1px solid rgba(209, 17, 17, 0.3);
        }

        .stats-table tr:last-child {
            border-bottom: none;
        }

        .stats-table .stat-label {
            color: #FFD700;
            font-size: 0.85em;
            padding: 8px 12px;
            text-align: left;
            font-weight: bold;
        }

        .stats-table .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 1.1em;
            padding: 8px 12px;
            text-align: right;
        }

        /* Buttons */
        .btn {
            background: #d11111;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5em;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .btn.secondary {
            background: #444;
            font-size: 1em;
            padding: 10px 30px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: none;
            padding: 15px;
            z-index: 5;
            pointer-events: none;
        }

        #hud.active {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-item {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .hud-label {
            font-size: 0.7em;
            color: #aaa;
            display: block;
        }

        .hud-value {
            color: #d11111;
        }

        /* Tutorial Modal */
        #tutorialModal {
            z-index: 20;
        }

        #tutorialModal .tutorial-content {
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: hidden;
            border: 2px solid #d11111;
            box-sizing: border-box;
        }

        #tutorialModal h2 {
            color: #d11111;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .tutorial-slide {
            display: none;
        }

        .tutorial-slide.active {
            display: block;
        }

        .tutorial-section {
            margin: 15px 0;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
            overflow-wrap: break-word;
        }

        .tutorial-section h3 {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            word-wrap: break-word;
        }

        .tutorial-section p {
            color: #ccc;
            line-height: 1.5;
            margin: 6px 0;
            word-wrap: break-word;
        }

        .tutorial-visual-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
            width: 100%;
            box-sizing: border-box;
        }

        .tutorial-visual-item {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            min-width: 0;
        }

        .tutorial-visual-item img {
            width: 60px;
            height: 60px;
            max-width: 100%;
            object-fit: contain;
            margin-bottom: 8px;
        }

        .tutorial-visual-item p {
            color: #fff;
            font-size: 0.9em;
            margin: 5px 0;
        }

        .tutorial-visual-item small {
            color: #aaa;
            font-size: 0.8em;
        }

        .tutorial-icon {
            display: inline-block;
            width: 30px;
            height: 30px;
            vertical-align: middle;
            margin: 0 5px;
            border-radius: 50%;
        }

        .tutorial-navigation {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tutorial-navigation .btn {
            padding: 12px 18px;
            font-size: 1em;
            margin: 3px;
            flex: 0 1 auto;
            min-width: 70px;
        }
        
        .tutorial-navigation .btn.secondary {
            padding: 10px 15px;
            font-size: 0.9em;
            flex: 0 1 auto;
        }

        .tutorial-dots {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 15px 0;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            cursor: pointer;
        }

        .tutorial-dot.active {
            background: #d11111;
        }

        /* Settings/Pause/Mute Buttons */
        #settingsBtn, #pauseBtn, #muteBtn {
            position: absolute;
            bottom: 70px;
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 1.5em;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 6;
            pointer-events: auto;
            transition: left 0.3s ease, right 0.3s ease, bottom 0.3s ease;
        }
        
        /* Right handed mode (default): settings on left, mute above pause on right */
        #settingsBtn.right-handed {
            left: 15px;
        }
        
        #pauseBtn.right-handed {
            right: 15px;
            bottom: 70px;
        }
        
        #muteBtn.right-handed {
            right: 15px;
            bottom: 125px;
        }
        
        /* Left handed mode: settings on right, mute above pause on left */
        #settingsBtn.left-handed {
            right: 15px;
        }
        
        #pauseBtn.left-handed {
            left: 15px;
            bottom: 70px;
        }
        
        #muteBtn.left-handed {
            left: 15px;
            bottom: 125px;
        }

        #settingsBtn.active, #pauseBtn.active, #muteBtn.active {
            display: flex;
        }

        /* Settings Menu */
        #settingsMenu {
            z-index: 20;
        }

        #settingsMenu .settings-content {
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            border: 2px solid #d11111;
        }
        
        /* Unlockables Menu */
        #unlockablesMenu {
            z-index: 20;
        }

        #unlockablesMenu .settings-content {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            border: 2px solid #FFD700;
        }

        #unlockablesMenu h2 {
            color: #FFD700;
            font-size: 1.6em;
            margin-bottom: 10px;
            text-align: center;
        }
        
        /* Achievements Page */
        #achievementsPage {
            z-index: 20;
        }

        #settingsMenu h2 {
            color: #d11111;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .settings-option {
            margin: 8px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .settings-option:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .settings-option p {
            color: #fff;
            margin: 0;
            font-size: 1em;
        }

        .settings-section {
            margin: 10px 0;
            padding: 12px;
            background: linear-gradient(135deg, rgba(13, 69, 45, 0.3), rgba(5, 40, 26, 0.3));
            border-radius: 12px;
            border: 1px solid rgba(209, 17, 17, 0.3);
        }

        .settings-section h3 {
            color: #FFD700;
            font-size: 1.1em;
            margin: 0 0 8px 0;
            text-align: left;
            border-bottom: 2px solid rgba(209, 17, 17, 0.5);
            padding-bottom: 5px;
        }

        .skin-carousel {
            position: relative;
            margin-top: 5px;
        }
        
        .skin-carousel-container {
            display: flex;
            overflow: hidden;
            gap: 8px;
        }
        
        .skin-carousel-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .skin-carousel-nav button {
            background: rgba(209, 17, 17, 0.3);
            border: 2px solid #d11111;
            color: #fff;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.2s;
        }
        
        .skin-carousel-nav button:hover:not(:disabled) {
            background: #d11111;
            transform: scale(1.1);
        }
        
        .skin-carousel-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .skin-carousel-indicator {
            color: #FFD700;
            font-size: 1em;
            min-width: 60px;
            text-align: center;
        }

        .skin-item {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            text-align: center;
        }

        .skin-item:hover:not(.locked) {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .skin-item.selected {
            background: rgba(209, 17, 17, 0.2);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .skin-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.3);
        }

        .skin-preview {
            width: 45px;
            height: 45px;
            margin: 0 auto 5px;
            border-radius: 50%;
            position: relative;
        }

        .skin-name {
            font-size: 0.8em;
            color: #fff;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .skin-unlock {
            font-size: 0.65em;
            color: #aaa;
            line-height: 1.1;
        }

        .skin-item.locked .skin-unlock {
            color: #888;
        }

        .settings-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(209, 17, 17, 0.5), transparent);
            margin: 10px 0;
        }

        /* Pause Overlay */
        #pauseOverlay {
            z-index: 15;
        }

        #pauseOverlay h2 {
            color: #d11111;
            font-size: 3em;
            margin-bottom: 20px;
        }

        /* Leaderboard */
        #leaderboardSection {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 8px;
            max-width: 400px;
        }

        #leaderboardSection h3 {
            color: #d11111;
            margin-bottom: 8px;
            font-size: 1.3em;
        }

        .leaderboard-entry {
            color: #fff;
            padding: 5px 8px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95em;
        }

        .leaderboard-entry:first-child {
            color: #ffd700;
            font-weight: bold;
        }

        .initials-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #d11111;
            color: white;
            padding: 8px;
            font-size: 1em;
            text-align: center;
            text-transform: uppercase;
            width: 120px;
            margin: 10px;
            border-radius: 5px;
        }

        /* Shake animation for game over */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .shake {
            animation: shake 0.3s ease-in-out;
        }

        /* Pop animation for collectibles */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Slide animations for notifications */
        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
            to {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
        }

        /* Toast animations for achievements */
        @keyframes toastSlideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Consent Toast */
        #consentToast {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, rgba(1, 68, 33, 0.98) 0%, rgba(5, 45, 26, 0.98) 100%);
            border-top: 3px solid #FFD700;
            padding: 15px 20px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.8);
            transform: translateY(100%);
            transition: transform 0.4s ease-out;
        }

        #consentToast.show {
            transform: translateY(0);
        }

        .consent-text {
            color: #fff;
            font-size: 0.95em;
            line-height: 1.5;
            margin: 0;
        }

        .consent-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }

        .consent-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .consent-checkbox-wrapper input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #FFD700;
        }

        .consent-checkbox-wrapper label {
            color: #FFD700;
            font-size: 0.9em;
            cursor: pointer;
            user-select: none;
        }

        #consentAcceptBtn {
            padding: 10px 25px;
            background: linear-gradient(135deg, #d11111, #a00d0d);
            color: white;
            border: 2px solid #FFD700;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        #consentAcceptBtn:hover {
            background: linear-gradient(135deg, #e61414, #b50f0f);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            transform: scale(1.05);
        }

        #consentAcceptBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: scale(1);
        }

        /* Privacy Policy Modal */
        #privacyModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 25;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #privacyModal.active {
            display: flex;
        }

        .privacy-content {
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 15px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .privacy-header {
            padding: 20px;
            border-bottom: 2px solid #FFD700;
            background: linear-gradient(135deg, #014421, #053d26);
        }

        .privacy-header h2 {
            color: #FFD700;
            font-size: 1.8em;
            margin: 0;
            text-align: center;
        }

        .privacy-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
            color: #fff;
            line-height: 1.6;
        }

        .privacy-body h3 {
            color: #FFD700;
            font-size: 1.3em;
            margin: 20px 0 10px 0;
        }

        .privacy-body h3:first-child {
            margin-top: 0;
        }

        .privacy-body p {
            margin: 10px 0;
            font-size: 0.95em;
        }

        .privacy-body ul {
            margin: 10px 0;
            padding-left: 25px;
        }

        .privacy-body li {
            margin: 5px 0;
        }

        .privacy-footer {
            padding: 15px 20px;
            border-top: 2px solid #FFD700;
            text-align: center;
        }

        .privacy-link {
            color: #888;
            font-size: 0.75em;
            text-decoration: underline;
            cursor: pointer;
            display: inline-block;
            margin-top: 10px;
            transition: color 0.3s ease;
        }

        .privacy-link:hover {
            color: #FFD700;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen">
        <img id="splashLogo" src="https://prometheangamescom.wordpress.com/wp-content/uploads/2025/11/header-logov2-cropped.png" alt="Scratch King">
        <button id="splashSettingsBtn">‚öôÔ∏è Settings</button>
        <button id="splashLeaderboardBtn">üèÜ Leaderboard</button>
        <button class="btn" id="splashPlayBtn">PLAY</button>
        <button id="splashHowToPlay">How to Play</button>
        <div id="splashCopyright">&copy; 2025 Promethean Games</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-item">
            <span class="hud-label">SCORE</span>
            <span id="currentScore" class="hud-value">0</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">TIME</span>
            <span id="runTimer" class="hud-value">0:00</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">HIGH SCORE</span>
            <span id="highScore" class="hud-value">0</span>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="gameOver" class="overlay">
        <table class="stats-table">
            <tr>
                <td class="stat-label">SCORE</td>
                <td class="stat-value" id="finalScore">0</td>
            </tr>
            <tr>
                <td class="stat-label">TIME</td>
                <td class="stat-value" id="finalTime">0:00</td>
            </tr>
            <tr>
                <td class="stat-label">FLAMES</td>
                <td class="stat-value" id="finalFlames">0</td>
            </tr>
            <tr>
                <td class="stat-label">NEAR MISSES</td>
                <td class="stat-value" id="finalNearMisses">0</td>
            </tr>
            <tr>
                <td class="stat-label">JUMPED BALLS</td>
                <td class="stat-value" id="finalJumpedBalls">0</td>
            </tr>
            <tr>
                <td class="stat-label">AIR TIME</td>
                <td class="stat-value" id="finalAirTime">0.0s</td>
            </tr>
            <tr>
                <td class="stat-label">DISTANCE</td>
                <td class="stat-value" id="finalDistance">0"</td>
            </tr>
        </table>
        
        <div id="initialsPrompt" style="display: none;">
            <p style="color: #FFD700; font-size: 1.2em; margin: 10px 0;">üèÜ NEW HIGH SCORE!</p>
            <input type="text" class="initials-input" id="initialsInput" maxlength="3" placeholder="AAA">
            <button class="btn" id="submitInitials">Submit</button>
        </div>

        <div id="leaderboardSection">
            <h3 style="color: #FFD700;">LEADERBOARD</h3>
            <div id="leaderboardList"></div>
        </div>

        <button class="btn" id="playAgainBtn">PLAY AGAIN</button>
        <button class="btn secondary" id="backToMenuBtn">BACK TO MENU</button>
        <button class="btn secondary" id="shareScoreBtn" style="display:none;">üì∏ Screenshot</button>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorialModal" class="overlay">
        <div class="tutorial-content">
            <h2>How to Play</h2>
            
            <!-- Slide 1: Controls -->
            <div class="tutorial-slide active" data-slide="0">
                <div class="tutorial-section">
                    <h3>üéÆ Your Cue Ball</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <svg width="100" height="100" viewBox="0 0 100 100">
                            <circle cx="50" cy="50" r="45" fill="#FFFFFF" stroke="#ddd" stroke-width="2"/>
                            <circle cx="35" cy="35" r="12" fill="rgba(255, 255, 255, 0.3)"/>
                        </svg>
                    </div>
                    <p><strong>Mobile:</strong> Swipe left or right to change lanes</p>
                    <p><strong>Desktop:</strong> Use Arrow Keys or A/D to move</p>
                    <p>Stay in your lane and dodge incoming hazards!</p>
                </div>
            </div>

            <!-- Slide 2: Hazards -->
            <div class="tutorial-slide" data-slide="1">
                <div class="tutorial-section">
                    <h3>‚ö†Ô∏è Hazards</h3>
                    <div class="tutorial-visual-grid">
                        <div class="tutorial-visual-item">
                            <svg width="80" height="80" viewBox="0 0 80 80">
                                <circle cx="40" cy="40" r="36" fill="#CC0000"/>
                                <circle cx="40" cy="40" r="18" fill="white"/>
                                <text x="40" y="48" font-family="Arial" font-size="24" font-weight="bold" fill="#CC0000" text-anchor="middle">3</text>
                                <circle cx="28" cy="28" r="10" fill="rgba(255, 255, 255, 0.3)"/>
                            </svg>
                            <p><strong>Solid Balls</strong></p>
                            <small>Numbers 1-7<br>Move straight</small>
                        </div>
                        <div class="tutorial-visual-item">
                            <svg width="80" height="80" viewBox="0 0 80 80">
                                <circle cx="40" cy="40" r="36" fill="#0066CC"/>
                                <rect x="4" y="34" width="72" height="12" fill="white"/>
                                <circle cx="40" cy="40" r="18" fill="white"/>
                                <text x="40" y="48" font-family="Arial" font-size="24" font-weight="bold" fill="#0066CC" text-anchor="middle">10</text>
                                <circle cx="28" cy="28" r="10" fill="rgba(255, 255, 255, 0.3)"/>
                            </svg>
                            <p><strong>Striped Balls</strong></p>
                            <small>Numbers 9-15<br>Move straight</small>
                        </div>
                        <div class="tutorial-visual-item">
                            <svg width="80" height="80" viewBox="0 0 80 80">
                                <circle cx="40" cy="40" r="36" fill="#000000"/>
                                <circle cx="40" cy="40" r="18" fill="white"/>
                                <text x="40" y="48" font-family="Arial" font-size="24" font-weight="bold" fill="#000000" text-anchor="middle">8</text>
                                <circle cx="28" cy="28" r="10" fill="rgba(255, 255, 255, 0.3)"/>
                            </svg>
                            <p><strong>8-Ball</strong></p>
                            <small>Zigzags!<br>Most dangerous</small>
                        </div>
                    </div>
                    <p style="text-align: center; color: #d11111; font-weight: bold;">Any collision ends your run!</p>
                </div>
            </div>

            <!-- Slide 3: Collectibles & Combos -->
            <div class="tutorial-slide" data-slide="2">
                <div class="tutorial-section">
                    <h3>üî• Collectibles</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <svg width="80" height="100" viewBox="0 0 80 100">
                            <!-- Outer red flame layer -->
                            <path d="M 40,70 Q 25,60 22,40 Q 20,20 40,5 Q 60,20 58,40 Q 55,60 40,70 Z" fill="#FF4500"/>
                            <!-- Middle orange flame layer -->
                            <path d="M 40,65 Q 28,58 26,42 Q 24,26 40,12 Q 56,26 54,42 Q 52,58 40,65 Z" fill="#FF8C00"/>
                            <!-- Inner yellow flame core -->
                            <path d="M 40,58 Q 32,52 30,42 Q 28,32 40,20 Q 52,32 50,42 Q 48,52 40,58 Z" fill="#FFD700"/>
                            <!-- Bright white-yellow core highlight -->
                            <path d="M 40,50 Q 35,46 34,40 Q 33,34 40,28 Q 47,34 46,40 Q 45,46 40,50 Z" fill="rgba(255, 255, 200, 0.9)"/>
                        </svg>
                    </div>
                    <p><strong>Golden Flames:</strong> Collect for points!</p>
                    <p><strong>Combo System:</strong> Collect flames consecutively within 2 seconds</p>
                    <p><strong>Multipliers:</strong> Build up to 5x score multiplier!</p>
                    <p style="text-align: center;">üí° <em>Chain flames together for massive scores!</em></p>
                </div>
            </div>

            <!-- Slide 4: Power-ups -->
            <div class="tutorial-slide" data-slide="3">
                <div class="tutorial-section">
                    <h3>‚≠ê Power-ups</h3>
                    <div style="text-align: center; margin: 20px 0;">
                        <svg width="100" height="100" viewBox="0 0 100 100">
                            <polygon points="50,10 61,38 90,38 67,56 77,85 50,67 23,85 33,56 10,38 39,38" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>
                            <polygon points="50,20 58,40 78,40 62,51 68,72 50,60 32,72 38,51 22,40 42,40" fill="#FFED4E"/>
                        </svg>
                    </div>
                    <p><strong>Jump Man Power-up:</strong> Golden rotating star</p>
                    <p>‚úì Jump OVER obstacles for 5 seconds</p>
                    <p>‚úì Grants +5 bonus seconds to your run timer</p>
                    <p>‚úì Watch your cue ball bounce as you leap!</p>
                    <p style="text-align: center;">üí° <em>Time your collection to pass through dense obstacle clusters!</em></p>
                </div>
            </div>

            <div class="tutorial-dots">
                <div class="tutorial-dot active" data-dot="0"></div>
                <div class="tutorial-dot" data-dot="1"></div>
                <div class="tutorial-dot" data-dot="2"></div>
                <div class="tutorial-dot" data-dot="3"></div>
            </div>

            <div class="tutorial-navigation">
                <button class="btn secondary" id="tutorialSkip">Skip</button>
                <button class="btn secondary" id="tutorialPrev" style="display:none;">Previous</button>
                <button class="btn secondary" id="tutorialViewAchievements" style="display:none;">üèÜ View Achievements</button>
                <button class="btn" id="tutorialNext">Next</button>
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="overlay">
        <div class="settings-content">
            <h2 id="settingsTitle">‚öôÔ∏è Settings</h2>
            
            <!-- Game Options -->
            <div class="settings-option" id="toggleHandednessOption">
                <p id="handednessToggleText">ü§ö Right Handed</p>
            </div>
            <div class="settings-option" id="toggleAudioOption">
                <p id="audioToggleText">üîä Mute Audio</p>
            </div>
            
            <div class="settings-divider"></div>

            <!-- Navigation Options -->
            <div class="settings-option" id="viewStatsOption">
                <p>üìä My Stats</p>
            </div>
            <div class="settings-option" id="viewUnlockablesOption">
                <p>üéÅ Unlockables</p>
            </div>
            <div class="settings-option" id="viewTutorialOption">
                <p>üìñ View Tutorial</p>
            </div>
            
            <div class="privacy-link" id="privacyPolicyLink">Privacy Policy & Terms of Use</div>
            
            <button class="btn" id="closeSettingsBtn" style="margin-top: 15px;">Close</button>
        </div>
    </div>

    <!-- Unlockables Menu -->
    <div id="unlockablesMenu" class="overlay">
        <div class="settings-content">
            <h2>üéÅ Unlockables</h2>
            
            <!-- Cue Ball Skins Section - Accordion -->
            <div class="settings-section">
                <button id="skinsAccordionBtn" style="width: 100%; padding: 12px; background: rgba(0,0,0,0.7); color: #0F0; border: 1px solid #0F0; border-radius: 4px; cursor: pointer; font-size: 1em; font-weight: bold;">üé± Cue Ball Skins ‚ñº</button>
                <div id="skinsCarouselWrapper" style="display: none; margin-top: 12px;">
                    <div class="skin-carousel">
                        <div class="skin-carousel-container" id="skinCarouselContainer">
                            <!-- Populated dynamically -->
                        </div>
                        <div class="skin-carousel-nav">
                            <button id="skinPrevBtn">‚óÄ</button>
                            <span class="skin-carousel-indicator" id="skinIndicator">1/5</span>
                            <button id="skinNextBtn">‚ñ∂</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-divider"></div>

            <!-- Unlockable Options -->
            <div class="settings-option">
                <p style="margin-bottom: 8px;">üéµ Music</p>
                <select id="musicSelect" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.7); color: #0F0; border: 1px solid #0F0; border-radius: 4px; cursor: pointer;">
                    <!-- Populated dynamically -->
                </select>
            </div>
            <div class="settings-option">
                <p style="margin-bottom: 8px;">üé® Theme</p>
                <select id="themeSelect" style="width: 100%; padding: 8px; background: rgba(0,0,0,0.7); color: #0F0; border: 1px solid #0F0; border-radius: 4px; cursor: pointer;">
                    <!-- Populated dynamically -->
                </select>
            </div>
            
            <div class="settings-divider"></div>

            <!-- Navigation Options -->
            <div class="settings-option" id="viewAchievementsOption">
                <p>üèÜ View Achievements</p>
            </div>
            
            <button class="btn" id="closeUnlockablesBtn" style="margin-top: 8px;">Back</button>
        </div>
    </div>

    <!-- Achievements Page -->
    <div id="achievementsPage" class="overlay">
        <div class="tutorial-content" style="max-height: 85vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0; color: #0F0;">üèÜ Achievements</h2>
                <div id="lifetimeFlamesCounter" style="color: #FFD700; font-size: 1.2em; font-weight: bold;">üî• 0</div>
            </div>
            <div id="achievementsList"></div>
            <button class="btn" id="closeAchievementsBtn" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- My Stats Modal -->
    <div id="statsModal" class="overlay" style="display: none;">
        <div class="tutorial-content" style="max-height: 85vh; overflow-y: auto;">
            <h2 style="color: #00FF00;">üìä My Stats</h2>
            <div id="statsContent" style="font-family: 'Courier New', monospace; font-size: 0.9em; text-align: left; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; color: #0F0;">
                <!-- Populated dynamically -->
            </div>
            <button class="btn" id="closeStatsBtn" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- Developer Analytics Dashboard (Hidden) -->
    <div id="analyticsPanel" class="overlay" style="display: none;">
        <div class="tutorial-content" style="max-height: 85vh; overflow-y: auto;">
            <h2 style="color: #00FF00;">üìä Developer Analytics</h2>
            <div id="analyticsContent" style="font-family: 'Courier New', monospace; font-size: 0.9em; text-align: left; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; color: #0F0;">
                <!-- Populated dynamically -->
            </div>
            <button class="btn" id="closeAnalyticsBtn" style="margin-top: 20px;">Close</button>
            <button class="btn secondary" id="exportAnalyticsBtn" style="margin-top: 10px;">üìã Copy to Clipboard</button>
        </div>
    </div>

    <!-- Pause Overlay -->
    <div id="pauseOverlay" class="overlay">
        <h2>‚è∏Ô∏è PAUSED</h2>
        <button class="btn" id="resumeBtn">Resume</button>
        <button class="btn" id="pauseSettingsBtn">‚öôÔ∏è Settings</button>
        <button class="btn secondary" id="pauseMenuBtn">Back to Menu</button>
    </div>

    <!-- Settings Button (visible during gameplay) -->
    <div id="settingsBtn">‚öôÔ∏è</div>
    
    <!-- Mute Button (visible during gameplay) -->
    <div id="muteBtn">üîä</div>

    <!-- Pause Button (visible during gameplay) -->
    <div id="pauseBtn">‚è∏Ô∏è</div>

    <!-- Consent Toast -->
    <div id="consentToast">
        <p class="consent-text">
            üéÆ Help us improve Scratch King! We'd like to collect anonymous gameplay stats (scores, achievements, play time), 
            technical info (device type, browser), and engagement metrics. No personal information is collected.
        </p>
        <div class="consent-controls">
            <div class="consent-checkbox-wrapper">
                <input type="checkbox" id="consentCheckbox">
                <label for="consentCheckbox">Allow analytics to help improve the game</label>
            </div>
            <button id="consentAcceptBtn" disabled>Thanks Devs!</button>
        </div>
    </div>

    <!-- Privacy Policy Modal -->
    <div id="privacyModal">
        <div class="privacy-content">
            <div class="privacy-header">
                <h2>Privacy Policy & Terms of Use</h2>
            </div>
            <div class="privacy-body">
                <h3>Privacy Policy</h3>
                <p><strong>Effective Date:</strong> November 20, 2025</p>
                <p><strong>Last Updated:</strong> November 20, 2025</p>
                
                <h3>1. Information We Collect</h3>
                <p>Scratch King is a privacy-first game. With your consent, we may collect anonymous analytics data to improve gameplay:</p>
                <ul>
                    <li><strong>Gameplay Data:</strong> Scores, achievements unlocked, session duration, game modes played</li>
                    <li><strong>Technical Data:</strong> Device type, screen resolution, browser type and version</li>
                    <li><strong>Engagement Data:</strong> Daily/weekly active sessions, feature usage, retention metrics</li>
                </ul>
                <p><strong>We do NOT collect:</strong> Names, email addresses, IP addresses, precise location data, or any personally identifiable information.</p>
                
                <h3>2. How We Use Your Information</h3>
                <p>Analytics data is used solely to:</p>
                <ul>
                    <li>Optimize game performance and user experience</li>
                    <li>Understand which features players enjoy most</li>
                    <li>Fix bugs and improve game balance</li>
                    <li>Make informed decisions about future updates</li>
                </ul>
                
                <h3>3. Data Storage</h3>
                <p>All game data (high scores, achievements, unlocks, settings) is stored locally on your device using browser localStorage. This data never leaves your device unless you explicitly share it (e.g., via screenshot feature).</p>
                
                <h3>4. Your Rights & Choices</h3>
                <ul>
                    <li><strong>Opt-Out:</strong> You can decline analytics at any time by not checking the consent box</li>
                    <li><strong>Data Deletion:</strong> Clear your browser's localStorage to delete all local game data</li>
                    <li><strong>No Tracking:</strong> We do not use cookies or third-party tracking scripts</li>
                </ul>
                
                <h3>5. Third-Party Services</h3>
                <p>Scratch King operates entirely offline. We do not integrate with third-party analytics services, advertisers, or social media platforms without additional explicit consent.</p>
                
                <h3>6. Children's Privacy</h3>
                <p>Scratch King is suitable for all ages. We do not knowingly collect personal information from children under 13. Parents can supervise gameplay and manage consent preferences.</p>
                
                <h3>7. Changes to This Policy</h3>
                <p>We may update this Privacy Policy periodically. Changes will be reflected with a new "Last Updated" date. Continued use of the game constitutes acceptance of the updated policy.</p>
                
                <h3>Terms of Use</h3>
                
                <h3>8. License & Usage</h3>
                <p>Scratch King is provided free of charge for personal entertainment. You may:</p>
                <ul>
                    <li>Play the game on any compatible device</li>
                    <li>Share screenshots and scores on social media</li>
                    <li>Recommend the game to others</li>
                </ul>
                <p>You may NOT:</p>
                <ul>
                    <li>Reverse engineer, decompile, or modify the game code</li>
                    <li>Use the game for commercial purposes without permission</li>
                    <li>Remove or obscure copyright notices or credits</li>
                </ul>
                
                <h3>9. Disclaimer of Warranties</h3>
                <p>Scratch King is provided "as is" without warranties of any kind. We do not guarantee uninterrupted, error-free operation. Use at your own risk.</p>
                
                <h3>10. Limitation of Liability</h3>
                <p>Promethean Games shall not be liable for any damages arising from use or inability to use Scratch King, including loss of data or interruption of service.</p>
                
                <h3>11. Intellectual Property</h3>
                <p>All game content, including graphics, audio, code, and design, is &copy; 2025 Promethean Games. All rights reserved.</p>
                
                <h3>12. Contact</h3>
                <p>Questions about this Privacy Policy or Terms of Use? Please contact us through our official website or support channels.</p>
                
                <p style="margin-top: 20px; font-size: 0.9em; color: #888;">
                    By playing Scratch King, you acknowledge that you have read and agree to this Privacy Policy and Terms of Use.
                </p>
            </div>
            <div class="privacy-footer">
                <button class="btn" id="closePrivacyBtn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // SPLASH SCREEN LOGIC
        // ============================================================
        const splashScreen = document.getElementById('splashScreen');
        const splashPlayBtn = document.getElementById('splashPlayBtn');
        
        // After 3 seconds, fade in all splash screen buttons
        function showSplashButtons(animated = true) {
            if (animated) {
                setTimeout(() => {
                    splashPlayBtn.classList.add('visible');
                    document.getElementById('splashHowToPlay').classList.add('visible');
                    document.getElementById('splashSettingsBtn').classList.add('visible');
                    document.getElementById('splashLeaderboardBtn').classList.add('visible');
                }, 3000);
                // Fade in copyright after 5 seconds
                setTimeout(() => {
                    document.getElementById('splashCopyright').classList.add('visible');
                }, 5000);
            } else {
                // Show immediately without animation
                splashPlayBtn.classList.add('visible');
                document.getElementById('splashHowToPlay').classList.add('visible');
                document.getElementById('splashSettingsBtn').classList.add('visible');
                document.getElementById('splashLeaderboardBtn').classList.add('visible');
                document.getElementById('splashCopyright').classList.add('visible');
            }
        }
        
        // Initial button display with animation
        showSplashButtons(true);
        
        // Handle splash Play button click - start game directly
        splashPlayBtn.addEventListener('click', () => {
            console.log('Splash Play button clicked - starting game');
            splashScreen.classList.add('hidden');
            startGame();
        });
        
        // Handle "How to Play" link click - show tutorial
        document.getElementById('splashHowToPlay').addEventListener('click', () => {
            console.log('How to Play clicked - opening tutorial');
            splashScreen.classList.add('hidden');
            currentTutorialSlide = 0;
            updateTutorialSlide();
            document.getElementById('tutorialModal').classList.add('active');
        });
        
        // Handle Settings button on splash screen
        document.getElementById('splashSettingsBtn').addEventListener('click', () => {
            console.log('Splash Settings clicked - opening settings');
            splashScreen.classList.add('hidden');
            updateMusicText();
            updateThemeText();
            renderSkinGrid();
            document.getElementById('settingsMenu').classList.add('active');
        });
        
        // Handle Leaderboard button on splash screen
        document.getElementById('splashLeaderboardBtn').addEventListener('click', () => {
            console.log('Splash Leaderboard clicked - showing leaderboard');
            splashScreen.classList.add('hidden');
            showLeaderboardOverlay();
        });
        
        // Function to update leaderboard button state
        function updateLeaderboardButtonState() {
            const leaderboardBtn = document.getElementById('splashLeaderboardBtn');
            if (leaderboard.length === 0) {
                leaderboardBtn.disabled = true;
            } else {
                leaderboardBtn.disabled = false;
            }
        }
        
        // Function to show leaderboard as an overlay
        function showLeaderboardOverlay() {
            // Create temporary leaderboard overlay if it doesn't exist
            let leaderboardOverlay = document.getElementById('leaderboardOverlay');
            if (!leaderboardOverlay) {
                leaderboardOverlay = document.createElement('div');
                leaderboardOverlay.id = 'leaderboardOverlay';
                leaderboardOverlay.className = 'overlay';
                leaderboardOverlay.innerHTML = `
                    <div class="tutorial-content" style="max-height: 85vh; overflow-y: auto;">
                        <h2>üèÜ LEADERBOARD</h2>
                        <div id="splashLeaderboardList"></div>
                        <button class="btn" id="closeSplashLeaderboardBtn" style="margin-top: 20px;">Close</button>
                    </div>
                `;
                document.body.appendChild(leaderboardOverlay);
                
                document.getElementById('closeSplashLeaderboardBtn').addEventListener('click', () => {
                    leaderboardOverlay.classList.remove('active');
                    splashScreen.classList.remove('hidden');
                    showSplashButtons(false); // Show buttons without animation
                });
            }
            
            // Populate leaderboard table
            const listElement = document.getElementById('splashLeaderboardList');
            listElement.innerHTML = '';
            
            if (leaderboard.length === 0) {
                listElement.innerHTML = '<p style="color: #aaa; text-align: center; padding: 20px;">No scores yet. Play to set a record!</p>';
            } else {
                // Create table
                const table = document.createElement('table');
                table.style.cssText = `
                    width: 100%;
                    border-collapse: collapse;
                    margin: 0 auto;
                    background: rgba(0, 0, 0, 0.3);
                    border-radius: 10px;
                    overflow: hidden;
                `;
                
                // Table header
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr style="background: rgba(209, 17, 17, 0.3); border-bottom: 2px solid #d11111;">
                        <th style="padding: 12px; text-align: center; color: #FFD700; font-size: 1em;">Rank</th>
                        <th style="padding: 12px; text-align: left; color: #FFD700; font-size: 1em;">Player</th>
                        <th style="padding: 12px; text-align: right; color: #FFD700; font-size: 1em;">Score</th>
                        <th style="padding: 12px; text-align: right; color: #FFD700; font-size: 1em;">Time</th>
                    </tr>
                `;
                table.appendChild(thead);
                
                // Table body
                const tbody = document.createElement('tbody');
                leaderboard.slice(0, 10).forEach((entry, index) => {
                    const tr = document.createElement('tr');
                    tr.style.cssText = `
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                        transition: background 0.2s;
                    `;
                    tr.onmouseover = () => tr.style.background = 'rgba(255, 255, 255, 0.05)';
                    tr.onmouseout = () => tr.style.background = 'transparent';
                    
                    // Medal emoji for top 3
                    let rankDisplay = `#${index + 1}`;
                    if (index === 0) rankDisplay = 'ü•á';
                    else if (index === 1) rankDisplay = 'ü•à';
                    else if (index === 2) rankDisplay = 'ü•â';
                    
                    tr.innerHTML = `
                        <td style="padding: 12px; text-align: center; color: #fff; font-size: 1.2em;">${rankDisplay}</td>
                        <td style="padding: 12px; text-align: left; color: #fff; font-weight: bold; font-size: 1.1em;">${entry.initials}</td>
                        <td style="padding: 12px; text-align: right; color: #FFD700; font-weight: bold; font-size: 1.1em;">${entry.score}</td>
                        <td style="padding: 12px; text-align: right; color: #aaa; font-size: 1em;">${entry.time || '‚Äî'}</td>
                    `;
                    tbody.appendChild(tr);
                });
                table.appendChild(tbody);
                
                listElement.appendChild(table);
            }
            
            leaderboardOverlay.classList.add('active');
        }

        // ============================================================
        // GAME CONSTANTS AND CONFIGURATION
        // ============================================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to match viewport
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const LANE_COUNT = 3;
        const PLAYER_RADIUS = 25;
        const OBSTACLE_RADIUS = 22;
        const COLLECTIBLE_RADIUS = 18;
        const INITIAL_SPEED = 3;
        const SPEED_INCREMENT = 0.0003;
        const MAX_SPEED = 12;
        const INITIAL_SPAWN_INTERVAL = 1500;
        const MIN_SPAWN_INTERVAL = 600;
        const SPAWN_DECREASE_RATE = 0.5;
        const COLLECTIBLE_POINTS = 50;
        const DISTANCE_POINTS_PER_FRAME = 0.1;

        // Pool ball colors (matching standard American pool rack)
        const BALL_COLORS = {
            solids: [
                { color: '#FFD700', number: 1, name: 'yellow' },      // 1 - Yellow
                { color: '#0066CC', number: 2, name: 'blue' },        // 2 - Blue
                { color: '#CC0000', number: 3, name: 'red' },         // 3 - Red
                { color: '#660099', number: 4, name: 'purple' },      // 4 - Purple
                { color: '#FF6600', number: 5, name: 'orange' },      // 5 - Orange
                { color: '#228B22', number: 6, name: 'green' },       // 6 - Green
                { color: '#800000', number: 7, name: 'maroon' }       // 7 - Maroon
            ],
            striped: [
                { color: '#FFD700', number: 9, name: 'yellow-striped' },   // 9 - Yellow striped
                { color: '#0066CC', number: 10, name: 'blue-striped' },    // 10 - Blue striped
                { color: '#CC0000', number: 11, name: 'red-striped' },     // 11 - Red striped
                { color: '#660099', number: 12, name: 'purple-striped' },  // 12 - Purple striped
                { color: '#FF6600', number: 13, name: 'orange-striped' },  // 13 - Orange striped
                { color: '#228B22', number: 14, name: 'green-striped' },   // 14 - Green striped
                { color: '#800000', number: 15, name: 'maroon-striped' }   // 15 - Maroon striped
            ]
        };

        // Felt color system - can be changed when table skins are unlocked
        const FELT_COLORS = {
            default: { primary: '#064b2f', secondary: '#053d26', name: 'Classic Green', theme: 'default' },
            skyZaddy: { primary: '#1a1a2e', secondary: '#0f0f1a', name: 'Sky Zaddy', theme: 'sky_zaddy' }
            // Future unlockable felts can be added here
            // blue: { primary: '#1e3a5f', secondary: '#152a45', name: 'Ocean Blue' },
            // red: { primary: '#5f1e1e', secondary: '#451515', name: 'Ruby Red' }
        };

        let currentFeltColor = localStorage.getItem('scratchKingFeltColor') || 'default';

        // Apply felt color to canvas background
        function applyFeltColor() {
            const felt = FELT_COLORS[currentFeltColor] || FELT_COLORS.default;
            canvas.style.background = `linear-gradient(180deg, ${felt.primary} 0%, ${felt.secondary} 100%)`;
            document.body.style.background = felt.secondary;
        }
        
        // Check if Sky Zaddy theme is active
        function isSkyZaddyActive() {
            return achievementsProgress.unlocked.includes('sky_king') && currentFeltColor === 'skyZaddy';
        }
        
        // Theme selection toggle
        function cycleTheme() {
            const availableThemes = ['default'];
            const hasSkyZaddy = achievementsProgress.unlocked.includes('sky_king');
            
            if (hasSkyZaddy) {
                availableThemes.push('skyZaddy');
            }
            
            if (availableThemes.length <= 1) {
                console.log('No other themes unlocked yet');
                return;
            }
            
            const currentIndex = availableThemes.indexOf(currentFeltColor);
            const nextIndex = (currentIndex + 1) % availableThemes.length;
            const nextTheme = availableThemes[nextIndex];
            
            currentFeltColor = nextTheme;
            localStorage.setItem('scratchKingFeltColor', nextTheme);
            applyFeltColor();
            updateThemeText();
            console.log('Theme changed to:', FELT_COLORS[nextTheme].name);
        }
        
        function updateThemeText() {
            const hasSkyZaddy = achievementsProgress.unlocked.includes('sky_king');
            const themeText = document.getElementById('themeSelectText');
            const availableThemes = hasSkyZaddy ? 2 : 1;
            const currentTheme = FELT_COLORS[currentFeltColor] || FELT_COLORS.default;
            const currentIndex = currentFeltColor === 'default' ? 1 : 2;
            
            if (themeText) {
                themeText.textContent = `üé® Theme: ${currentTheme.name} (${currentIndex}/${availableThemes})`;
            }
        }

        // ============================================================
        // GAME STATE
        // ============================================================
        let gameState = 'menu'; // menu, playing, gameOver
        let playerLane = 1; // 0 = left, 1 = center, 2 = right
        let score = 0;
        let highScore = localStorage.getItem('scratchKingHighScore') || 0;
        let obstacles = [];
        let collectibles = [];
        let scrollOffset = 0;
        let gameSpeed = INITIAL_SPEED;
        let spawnInterval = INITIAL_SPAWN_INTERVAL;
        let lastSpawnTime = 0;
        let gameStartTime = 0;
        let animationFrameId = null;
        let leaderboard = JSON.parse(localStorage.getItem('scratchKingLeaderboard') || '[]');
        
        // Game statistics
        let nearMisses = 0;
        let flamesCollected = 0;
        let pixelsScrolled = 0;
        let totalAirTimeMs = 0;
        
        // Distance calculation: cue ball is 2.25 inches (57mm) in diameter
        // Using PLAYER_RADIUS * 2 as diameter in pixels
        const CUE_BALL_DIAMETER_INCHES = 2.25;
        const CUE_BALL_DIAMETER_MM = 57;
        const CUE_BALL_DIAMETER_PIXELS = PLAYER_RADIUS * 2;

        // Touch/swipe handling
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 50;

        // Particle system
        let particles = [];
        let playerTrail = [];
        const MAX_TRAIL_LENGTH = 15;

        // Combo system
        let combo = 0;
        let comboTimer = 0;
        const COMBO_TIMEOUT = 2000; // 2 seconds to maintain combo
        let lastCollectTime = 0;

        // Power-up system
        let powerUps = [];
        let jumpManActive = false;
        let jumpManDuration = 0;
        const JUMP_MAN_TIME = 8000; // 8 seconds - more generous for player comfort
        let playerJumpOffset = 0;
        let lastPowerUpSpawn = 0;
        const POWERUP_SPAWN_INTERVAL = 20000; // spawn every 20 seconds
        
        // Timer system
        let bonusTime = 0; // Bonus seconds from power-ups
        const POWERUP_BONUS_TIME = 5000; // 5 seconds in milliseconds
        
        // Jump tracking for achievements
        let jumpsThisRun = 0;
        let hazardsJumpedThisRun = 0;
        let trackedObstacles = new Set(); // Track which obstacles have been jumped over
        
        // Landing detection for splash effects
        let previousJumpOffset = 0;
        let hasLandedThisJump = true; // Prevents repeated splash triggers
        
        // Cruise control tracking for achievements
        let currentLaneStartTime = 0;
        let maxTimeInSameLane = 0; // Track the longest time in same lane this run

        // ============================================================
        // ACHIEVEMENTS SYSTEM
        // ============================================================
        const ACHIEVEMENTS = {
            chalk_rookie: { id: 'chalk_rookie', name: 'Chalk Rookie', desc: 'Survive 10 seconds', target: 10, type: 'time', reward: 'Table Skin: Practice Table', category: 'survival' },
            rack_veteran: { id: 'rack_veteran', name: 'Rack Veteran', desc: 'Survive 30 seconds', target: 30, type: 'time', reward: 'Cue Ball Skin: Chalk Dust', category: 'survival' },
            scratch_specialist: { id: 'scratch_specialist', name: 'Scratch Specialist', desc: 'Survive 60 seconds', target: 60, type: 'time', reward: 'Trail Effect: Tailwind Chalk Dust', category: 'survival' },
            untouchable: { id: 'untouchable', name: 'Untouchable', desc: 'Survive 90 seconds', target: 90, type: 'time', reward: 'Prestige Badge: Ghost Mode', category: 'survival' },
            scratch_prince: { id: 'scratch_prince', name: 'Scratch Prince', desc: 'Survive 120 seconds', target: 120, type: 'time', reward: 'Unlocks all hidden achievements', category: 'survival' },
            scratch_king: { id: 'scratch_king', name: 'Scratch King', desc: 'Survive 180 seconds', target: 180, type: 'time', reward: 'Cue Ball Skin: Kings Crown', category: 'survival' },
            coin_collector: { id: 'coin_collector', name: 'Private Collector', desc: '20 Golden Flames in one run', target: 20, type: 'flames_run', reward: 'Cue Ball Skin: Vintage Brass Tokens', category: 'collection' },
            hot_streak: { id: 'hot_streak', name: 'Hot Streak', desc: '10 Golden Flames in one run', target: 10, type: 'flames_run', reward: 'Table Edge Glow: Heatline Rails', category: 'collection' },
            master_embers: { id: 'master_embers', name: 'Master of Embers', desc: '30 Golden Flames in one run', target: 30, type: 'flames_run', reward: 'Cue Ball Skin: Flaming Crown', category: 'collection' },
            flame_keeper: { id: 'flame_keeper', name: 'Flame Keeper', desc: '100 lifetime Golden Flames', target: 100, type: 'flames_lifetime', reward: 'Cue Ball Skin: Flare Core', category: 'collection' },
            hoarder_flame: { id: 'hoarder_flame', name: 'Hoarder of the Flame', desc: '500 lifetime Golden Flames', target: 500, type: 'flames_lifetime', reward: 'SFX Pack: Barroom Classic', category: 'collection' },
            pyromancer: { id: 'pyromancer', name: 'Pyromancer', desc: '1000 lifetime Golden Flames', target: 1000, type: 'flames_lifetime', reward: 'Cue Ball Skin: Fiery Crown', category: 'collection' },
            earned_my_wings: { id: 'earned_my_wings', name: 'Jump Wings', desc: 'Jump over 3 hazards in one run', target: 3, type: 'hazards_jumped', reward: 'Cue Ball Skin: Puddle Jumper', category: 'aerial' },
            air_baron: { id: 'air_baron', name: 'Wright Time', desc: 'Total air time of 12+ seconds in one run', target: 12, type: 'air_time', reward: 'Trail Effect: Flight Scarf', category: 'aerial' },
            sky_king: { id: 'sky_king', name: 'Sky King', desc: 'Jump over 25 hazards AND survive 60 seconds', target: { hazards: 25, time: 60 }, type: 'jump_combo', reward: 'Theme: Sky Zaddy', category: 'aerial' },
            distracted_driver: { id: 'distracted_driver', name: 'Distracted Driver', desc: 'Stay in same lane for 5 seconds', target: 5, type: 'cruise_control', reward: 'Cue Ball Skin: Bronze Steering Wheel', category: 'cruise' },
            hands_free: { id: 'hands_free', name: 'Hands Free', desc: 'Stay in same lane for 10 seconds', target: 10, type: 'cruise_control', reward: 'Cue Ball Skin: Silver Steering Wheel', category: 'cruise' },
            autopilot_engaged: { id: 'autopilot_engaged', name: 'Autopilot Engaged', desc: 'Stay in same lane for 15 seconds', target: 15, type: 'cruise_control', reward: 'Cue Ball Skin: Gold Steering Wheel', category: 'cruise' },
            pro_status: { id: 'pro_status', name: 'Pro Status', desc: 'Earn 10 achievements', target: 10, type: 'achievements', reward: 'Skins: Beach Ball & Baseball', category: 'mastery' },
            ascended_king: { id: 'ascended_king', name: 'Legend Status', desc: 'Earn all 20 achievements', target: 20, type: 'achievements', reward: 'Mythic Skins: Gold, Silver & Measles Ball', category: 'mastery' }
        };

        let achievementsProgress = JSON.parse(localStorage.getItem('scratchKingAchievements') || JSON.stringify({
            unlocked: [],
            flamesLifetime: 0,
            bestTime: 0,
            flamesThisRun: 0
        }));

        // Migrate old coin* fields to flames* fields for backwards compatibility
        if (achievementsProgress.coinsLifetime !== undefined) {
            achievementsProgress.flamesLifetime = achievementsProgress.coinsLifetime;
            delete achievementsProgress.coinsLifetime;
        }
        if (achievementsProgress.coinsThisRun !== undefined) {
            achievementsProgress.flamesThisRun = achievementsProgress.coinsThisRun;
            delete achievementsProgress.coinsThisRun;
        }
        // Ensure new fields exist with defaults
        achievementsProgress.flamesLifetime = achievementsProgress.flamesLifetime || 0;
        achievementsProgress.flamesThisRun = achievementsProgress.flamesThisRun || 0;
        // Save migrated data
        localStorage.setItem('scratchKingAchievements', JSON.stringify(achievementsProgress));

        function checkAchievements(currentTime) {
            const timeSeconds = Math.floor(currentTime / 1000);
            const flamesThisRun = achievementsProgress.flamesThisRun || 0;
            
            // Time-based achievements
            const timeAchievements = ['chalk_rookie', 'rack_veteran', 'scratch_specialist', 'untouchable', 'scratch_prince', 'scratch_king'];
            timeAchievements.forEach(id => {
                if (!achievementsProgress.unlocked.includes(id) && timeSeconds >= ACHIEVEMENTS[id].target) {
                    unlockAchievement(id);
                }
            });
            
            // Golden Flames per run achievements
            if (!achievementsProgress.unlocked.includes('hot_streak') && flamesThisRun >= 10) {
                unlockAchievement('hot_streak');
            }
            if (!achievementsProgress.unlocked.includes('coin_collector') && flamesThisRun >= 20) {
                unlockAchievement('coin_collector');
            }
            if (!achievementsProgress.unlocked.includes('master_embers') && flamesThisRun >= 30) {
                unlockAchievement('master_embers');
            }
            
            // Lifetime Golden Flames achievements
            const flamesLifetime = achievementsProgress.flamesLifetime || 0;
            if (!achievementsProgress.unlocked.includes('flame_keeper') && flamesLifetime >= 100) {
                unlockAchievement('flame_keeper');
            }
            if (!achievementsProgress.unlocked.includes('hoarder_flame') && flamesLifetime >= 500) {
                unlockAchievement('hoarder_flame');
            }
            if (!achievementsProgress.unlocked.includes('pyromancer') && flamesLifetime >= 1000) {
                unlockAchievement('pyromancer');
            }
            
            // Jump-based achievements
            if (!achievementsProgress.unlocked.includes('earned_my_wings') && hazardsJumpedThisRun >= 3) {
                unlockAchievement('earned_my_wings');
            }
            // Air time achievement (Wright Time) - 12+ seconds in air
            const totalAirTimeSeconds = totalAirTimeMs / 1000;
            if (!achievementsProgress.unlocked.includes('air_baron') && totalAirTimeSeconds >= 12) {
                unlockAchievement('air_baron');
            }
            if (!achievementsProgress.unlocked.includes('sky_king') && hazardsJumpedThisRun >= 25 && timeSeconds >= 60) {
                unlockAchievement('sky_king');
            }
            
            // Meta achievements (based on number of achievements, excluding meta achievements themselves)
            const unlockedCount = achievementsProgress.unlocked.filter(id => 
                id !== 'pro_status' && id !== 'ascended_king'
            ).length;
            
            if (!achievementsProgress.unlocked.includes('pro_status') && unlockedCount >= 10) {
                unlockAchievement('pro_status');
            }
            if (!achievementsProgress.unlocked.includes('ascended_king') && unlockedCount >= 15) {
                unlockAchievement('ascended_king');
            }
            
            // Cruise control achievements (staying in same lane)
            if (!achievementsProgress.unlocked.includes('distracted_driver') && maxTimeInSameLane >= 5) {
                unlockAchievement('distracted_driver');
            }
            if (!achievementsProgress.unlocked.includes('hands_free') && maxTimeInSameLane >= 10) {
                unlockAchievement('hands_free');
            }
            if (!achievementsProgress.unlocked.includes('autopilot_engaged') && maxTimeInSameLane >= 15) {
                unlockAchievement('autopilot_engaged');
            }
        }

        function unlockAchievement(id) {
            if (!achievementsProgress.unlocked.includes(id)) {
                achievementsProgress.unlocked.push(id);
                localStorage.setItem('scratchKingAchievements', JSON.stringify(achievementsProgress));
                console.log('Achievement unlocked:', ACHIEVEMENTS[id].name);
                showAchievementNotification(id);
            }
        }

        // Create toast container if it doesn't exist
        let toastContainer = null;
        function getToastContainer() {
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'achievementToastContainer';
                toastContainer.style.cssText = `
                    position: fixed;
                    bottom: 130px;
                    right: 20px;
                    display: flex;
                    flex-direction: column-reverse;
                    gap: 10px;
                    z-index: 1001;
                    pointer-events: none;
                `;
                document.body.appendChild(toastContainer);
            }
            return toastContainer;
        }

        function showAchievementNotification(id) {
            const achievement = ACHIEVEMENTS[id];
            console.log(`üèÜ ${achievement.name} - ${achievement.reward}`);
            
            const container = getToastContainer();
            
            // Create compact single-line toast notification
            const toast = document.createElement('div');
            toast.style.cssText = `
                background: rgba(17, 17, 17, 0.5);
                color: #FFD700;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 0.75em;
                box-shadow: 0 2px 8px rgba(0,0,0,0.4);
                animation: toastSlideIn 0.3s ease-out;
                border-left: 3px solid #FFD700;
                pointer-events: auto;
                margin-bottom: 0;
                white-space: nowrap;
            `;
            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 1.2em;">üèÜ</span>
                    <span style="font-weight: bold;">${achievement.name}</span>
                </div>
            `;
            container.appendChild(toast);
            
            // Auto-dismiss after 4 seconds
            setTimeout(() => {
                toast.style.animation = 'toastSlideOut 0.3s ease-in';
                setTimeout(() => {
                    toast.remove();
                    // Remove container if empty
                    if (container.children.length === 0) {
                        container.remove();
                        toastContainer = null;
                    }
                }, 300);
            }, 4000);
        }

        // ============================================================
        // PARTICLE SYSTEM
        // ============================================================
        function createExplosion(x, y, color) {
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 4,
                    color: color
                });
            }
        }

        function createCollectParticles(x, y) {
            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 3 + Math.random() * 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.03,
                    size: 4 + Math.random() * 3,
                    color: '#FFD700'
                });
            }
        }

        function createSplashParticles(x, y) {
            const particleCount = 16;
            for (let i = 0; i < particleCount; i++) {
                // Create splash that spreads horizontally more than vertically
                const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI * 0.8; // Upward splash with spread
                const speed = 2 + Math.random() * 4;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed * 1.5, // Wider horizontal spread
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.025 + Math.random() * 0.015,
                    size: 3 + Math.random() * 5,
                    color: i % 3 === 0 ? '#64B4FF' : (i % 3 === 1 ? '#3282FF' : '#96D4FF') // Blue water colors
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // gravity
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function renderParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function updatePlayerTrail(x, y) {
            playerTrail.unshift({ x, y, life: 1.0 });
            if (playerTrail.length > MAX_TRAIL_LENGTH) {
                playerTrail.pop();
            }
            
            // Decay trail
            for (let i = 0; i < playerTrail.length; i++) {
                playerTrail[i].life = 1 - (i / MAX_TRAIL_LENGTH);
            }
        }

        function renderPlayerTrail() {
            // Check if Flight Scarf is unlocked
            const hasFlightScarf = achievementsProgress.unlocked.includes('air_baron');
            const hasCracklingFire = achievementsProgress.unlocked.includes('master_embers');
            
            // Only render Flight Scarf trail when jumping and unlocked
            if (hasFlightScarf && jumpManActive) {
                // Flight Scarf: white dust trail during jumps
                for (let i = playerTrail.length - 1; i >= 0; i--) {
                    const trail = playerTrail[i];
                    const size = PLAYER_RADIUS * trail.life * 0.8;
                    
                    // Create soft, cloudy appearance with multiple layers
                    ctx.globalAlpha = trail.life * 0.15;
                    const gradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, size);
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.5, '#F0F0F0');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add a subtle secondary glow for depth
                    ctx.globalAlpha = trail.life * 0.08;
                    ctx.fillStyle = '#E8F4F8';
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, size * 1.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (!jumpManActive && hasCracklingFire) {
                // Crackling Fire Dust: animated fire trail when Master of Embers unlocked
                for (let i = playerTrail.length - 1; i >= 0; i--) {
                    const trail = playerTrail[i];
                    const baseSize = PLAYER_RADIUS * trail.life * 0.7;
                    
                    // Main fire core
                    ctx.globalAlpha = trail.life * 0.4;
                    const fireGradient = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, baseSize);
                    fireGradient.addColorStop(0, '#FFD700');
                    fireGradient.addColorStop(0.4, '#FF6600');
                    fireGradient.addColorStop(0.7, '#FF3300');
                    fireGradient.addColorStop(1, 'rgba(255, 51, 0, 0)');
                    ctx.fillStyle = fireGradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, baseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Crackling sparks - small random particles around trail
                    const sparkCount = Math.floor(3 * trail.life);
                    for (let s = 0; s < sparkCount; s++) {
                        const angle = (Date.now() / 100 + i * 5 + s * 2.5) % (Math.PI * 2);
                        const distance = baseSize * 0.6 * (0.5 + Math.random() * 0.5);
                        const sparkX = trail.x + Math.cos(angle) * distance;
                        const sparkY = trail.y + Math.sin(angle) * distance;
                        const sparkSize = 2 + Math.random() * 3;
                        
                        ctx.globalAlpha = trail.life * (0.3 + Math.random() * 0.4);
                        ctx.fillStyle = Math.random() > 0.5 ? '#FFD700' : '#FF6600';
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, sparkSize * trail.life, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Outer glow for fire effect
                    ctx.globalAlpha = trail.life * 0.15;
                    ctx.fillStyle = '#FF3300';
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, baseSize * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (!jumpManActive) {
                // Default trail (only when not jumping and no special trail unlocked)
                for (let i = playerTrail.length - 1; i >= 0; i--) {
                    const trail = playerTrail[i];
                    const size = PLAYER_RADIUS * trail.life * 0.6;
                    ctx.globalAlpha = trail.life * 0.3;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;
        }

        // ============================================================
        // UNLOCKABLE MUSIC SYSTEM
        // ============================================================
        const BACKGROUND_TRACKS = {
            hazardChase1: {
                id: 'hazardChase1',
                name: 'Hazard Chase 1',
                file: '/sounds/background.mp3',
                unlocked: true
            },
            hazardChase2: {
                id: 'hazardChase2',
                name: 'Hazard Chase 2',
                file: '/sounds/hazard-chase-2.mp3',
                unlocked: false,
                unlockCondition: 'Play 5 games'
            },
            whispersFog: {
                id: 'whispersFog',
                name: 'Whispers in the Fog',
                file: '/sounds/whispers-in-the-fog.mp3',
                unlocked: false,
                unlockCondition: 'Play 25 games'
            },
            cueBallSymphony: {
                id: 'cueBallSymphony',
                name: 'Cue Ball Symphony',
                file: '/sounds/cue-ball-symphony.mp3',
                unlocked: false,
                unlockCondition: 'Play 100 games',
                gameOverOnly: true
            }
        };

        // Load music progress from localStorage with migration
        let musicProgress = JSON.parse(localStorage.getItem('scratchKingMusic') || JSON.stringify({
            unlockedTracks: ['hazardChase1'],
            currentTrack: 'hazardChase1',
            gamesPlayed: 0,
            tutorialCompleted: false,
            hiddenAchievements: []
        }));
        
        // Migrate old 'classic' to 'hazardChase1'
        if (musicProgress.currentTrack === 'classic') {
            musicProgress.currentTrack = 'hazardChase1';
        }
        if (musicProgress.unlockedTracks && musicProgress.unlockedTracks.includes('classic')) {
            musicProgress.unlockedTracks = musicProgress.unlockedTracks.filter(t => t !== 'classic');
            if (!musicProgress.unlockedTracks.includes('hazardChase1')) {
                musicProgress.unlockedTracks.push('hazardChase1');
            }
        }
        
        // Ensure currentTrack exists in BACKGROUND_TRACKS
        if (!BACKGROUND_TRACKS[musicProgress.currentTrack]) {
            musicProgress.currentTrack = 'hazardChase1';
        }
        
        localStorage.setItem('scratchKingMusic', JSON.stringify(musicProgress));

        // Check if new tracks should be unlocked
        function checkMusicUnlocks() {
            const gamesPlayed = musicProgress.gamesPlayed || 0;
            
            // Hazard Chase 2 - 5 games
            if (gamesPlayed >= 5 && !musicProgress.unlockedTracks.includes('hazardChase2')) {
                unlockTrack('hazardChase2');
            }
            
            // Whispers in the Fog - 25 plays
            if (gamesPlayed >= 25 && !musicProgress.unlockedTracks.includes('whispersFog')) {
                unlockTrack('whispersFog');
            }
            
            // Cue Ball Symphony - 100 plays
            if (gamesPlayed >= 100 && !musicProgress.unlockedTracks.includes('cueBallSymphony')) {
                unlockTrack('cueBallSymphony');
            }
        }

        function unlockTrack(trackId) {
            if (!musicProgress.unlockedTracks.includes(trackId)) {
                musicProgress.unlockedTracks.push(trackId);
                BACKGROUND_TRACKS[trackId].unlocked = true;
                localStorage.setItem('scratchKingMusic', JSON.stringify(musicProgress));
                console.log('üéµ Track unlocked:', BACKGROUND_TRACKS[trackId].name);
                showTrackUnlockNotification(trackId);
            }
        }

        function showTrackUnlockNotification(trackId) {
            const track = BACKGROUND_TRACKS[trackId];
            console.log(`üéµ NEW TRACK UNLOCKED!\n${track.name}\nNow available in Settings!`);
            
            // Show visual notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #d11111, #ff6600);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 1.2em;
                font-weight: bold;
                z-index: 1001;
                box-shadow: 0 8px 16px rgba(0,0,0,0.5);
                animation: slideDown 0.5s ease-out;
                text-align: center;
            `;
            notification.innerHTML = `üéµ NEW TRACK UNLOCKED!<br><span style="font-size: 0.9em;">${track.name}</span><br><small style="font-size: 0.7em;">Check Settings to play!</small>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideUp 0.5s ease-in';
                setTimeout(() => notification.remove(), 500);
            }, 4000);
        }

        function incrementGamesPlayed() {
            musicProgress.gamesPlayed = (musicProgress.gamesPlayed || 0) + 1;
            localStorage.setItem('scratchKingMusic', JSON.stringify(musicProgress));
            console.log('Games played:', musicProgress.gamesPlayed);
            checkMusicUnlocks();
        }

        // ============================================================
        // SOUND MANAGEMENT
        // ============================================================
        const sounds = {
            collect: new Audio('/sounds/success.mp3'),
            scratch: new Audio('/sounds/hit.mp3'),
            start: new Audio(BACKGROUND_TRACKS[musicProgress.currentTrack || 'hazardChase1']?.file || BACKGROUND_TRACKS.hazardChase1.file),
            gameOverVoice: new Audio('/sounds/game-over-voice.mp3')
        };

        // Set volumes
        sounds.collect.volume = 0.5;
        sounds.scratch.volume = 0.6;
        sounds.start.volume = 0.3;
        sounds.start.loop = true;
        sounds.gameOverVoice.volume = 0.7;

        function playCollectSound() {
            sounds.collect.currentTime = 0;
            sounds.collect.play().catch(e => console.log('Sound play prevented:', e));
        }

        function playScratchSound() {
            sounds.scratch.currentTime = 0;
            sounds.scratch.play().catch(e => console.log('Sound play prevented:', e));
        }

        function playStartSound() {
            sounds.start.currentTime = 0;
            sounds.start.play().catch(e => console.log('Sound play prevented:', e));
        }

        function stopStartSound() {
            sounds.start.pause();
            sounds.start.currentTime = 0;
        }

        function playGameOverVoice() {
            const gamesPlayed = musicProgress.gamesPlayed || 0;
            if (gamesPlayed >= 10) {
                sounds.gameOverVoice.currentTime = 0;
                sounds.gameOverVoice.play().catch(e => console.log('Sound play prevented:', e));
            }
        }

        // Audio mute toggle
        let audioMuted = false;
        function toggleAudio() {
            audioMuted = !audioMuted;
            const muteText = audioMuted ? 'üîá Unmute Audio' : 'üîä Mute Audio';
            document.getElementById('audioToggleText').textContent = muteText;
            
            // Mute/unmute all sounds
            sounds.collect.muted = audioMuted;
            sounds.scratch.muted = audioMuted;
            sounds.start.muted = audioMuted;
            sounds.gameOverVoice.muted = audioMuted;
            
            console.log('Audio', audioMuted ? 'muted' : 'unmuted');
        }

        // Handedness toggle (right-handed by default)
        let isRightHanded = localStorage.getItem('handedness') !== 'left';
        
        function applyHandedness() {
            const settingsBtn = document.getElementById('settingsBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isRightHanded) {
                // Right handed: settings on left, pause on right
                settingsBtn.classList.remove('left-handed');
                settingsBtn.classList.add('right-handed');
                pauseBtn.classList.remove('left-handed');
                pauseBtn.classList.add('right-handed');
                document.getElementById('handednessToggleText').textContent = 'ü§ö Right Handed';
            } else {
                // Left handed: settings on right, pause on left
                settingsBtn.classList.remove('right-handed');
                settingsBtn.classList.add('left-handed');
                pauseBtn.classList.remove('right-handed');
                pauseBtn.classList.add('left-handed');
                document.getElementById('handednessToggleText').textContent = 'ü§ö Left Handed';
            }
            
            console.log('Handedness:', isRightHanded ? 'right-handed' : 'left-handed');
        }
        
        function toggleHandedness() {
            isRightHanded = !isRightHanded;
            localStorage.setItem('handedness', isRightHanded ? 'right' : 'left');
            applyHandedness();
        }

        // ============================================================
        // CUE BALL SKIN SYSTEM
        // ============================================================
        const CUE_BALL_SKINS = {
            default: {
                id: 'default',
                name: 'Classic',
                unlocked: true,
                achievementId: null,
                unlockDesc: 'Default skin',
                render: (ctx, x, y, radius) => {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },
            bronzeMetallic: {
                id: 'bronzeMetallic',
                name: 'Bronze Metallic',
                unlocked: false,
                achievementId: null,
                unlockDesc: 'Play 25 games',
                unlockCondition: () => (musicProgress.gamesPlayed || 0) >= 25,
                render: (ctx, x, y, radius) => {
                    // Bronze metallic gradient
                    const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
                    gradient.addColorStop(0, '#E8A75C');
                    gradient.addColorStop(0.4, '#CD7F32');
                    gradient.addColorStop(0.7, '#A0642D');
                    gradient.addColorStop(1, '#8B5A2B');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    ctx.fillStyle = 'rgba(255, 215, 150, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Subtle highlight streak
                    const highlightGradient = ctx.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
                    highlightGradient.addColorStop(0, 'rgba(255, 230, 180, 0.3)');
                    highlightGradient.addColorStop(0.5, 'rgba(205, 127, 50, 0)');
                    highlightGradient.addColorStop(1, 'rgba(139, 90, 43, 0.2)');
                    ctx.fillStyle = highlightGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = '#A0642D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },
            silverMetallic: {
                id: 'silverMetallic',
                name: 'Silver Metallic',
                unlocked: false,
                achievementId: null,
                unlockDesc: 'Play 50 games',
                unlockCondition: () => (musicProgress.gamesPlayed || 0) >= 50,
                render: (ctx, x, y, radius) => {
                    // Silver metallic gradient
                    const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
                    gradient.addColorStop(0, '#F0F0F0');
                    gradient.addColorStop(0.4, '#C0C0C0');
                    gradient.addColorStop(0.7, '#A8A8A8');
                    gradient.addColorStop(1, '#888888');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Chrome-like reflection
                    const highlightGradient = ctx.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
                    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                    highlightGradient.addColorStop(0.5, 'rgba(192, 192, 192, 0)');
                    highlightGradient.addColorStop(1, 'rgba(136, 136, 136, 0.3)');
                    ctx.fillStyle = highlightGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = '#A8A8A8';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },
            goldMetallic: {
                id: 'goldMetallic',
                name: 'Gold Metallic',
                unlocked: false,
                achievementId: null,
                unlockDesc: 'Play 100 games',
                unlockCondition: () => (musicProgress.gamesPlayed || 0) >= 100,
                render: (ctx, x, y, radius) => {
                    // Gold metallic gradient
                    const gradient = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, 0, x, y, radius);
                    gradient.addColorStop(0, '#FFE55C');
                    gradient.addColorStop(0.4, '#FFD700');
                    gradient.addColorStop(0.7, '#DAA520');
                    gradient.addColorStop(1, '#B8860B');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    ctx.fillStyle = 'rgba(255, 250, 205, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Golden glow
                    const highlightGradient = ctx.createLinearGradient(x - radius, y - radius, x + radius, y + radius);
                    highlightGradient.addColorStop(0, 'rgba(255, 245, 150, 0.5)');
                    highlightGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0)');
                    highlightGradient.addColorStop(1, 'rgba(184, 134, 11, 0.3)');
                    ctx.fillStyle = highlightGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Golden shimmer
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 8;
                    ctx.strokeStyle = '#DAA520';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            flareCore: {
                id: 'flareCore',
                name: 'Flare Core',
                unlocked: false,
                achievementId: 'flame_keeper',
                unlockDesc: '100 lifetime Golden Flames',
                render: (ctx, x, y, radius) => {
                    // Glowing orange/red core
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(0.5, '#FF6600');
                    gradient.addColorStop(1, '#CC0000');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pulsing glow effect
                    const pulseSize = radius * (1.2 + Math.sin(Date.now() / 200) * 0.1);
                    const glowGradient = ctx.createRadialGradient(x, y, radius * 0.5, x, y, pulseSize);
                    glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0)');
                    glowGradient.addColorStop(0.7, 'rgba(255, 102, 0, 0.2)');
                    glowGradient.addColorStop(1, 'rgba(255, 102, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 6, y - 6, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing border
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#FF6600';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            puddleJumper: {
                id: 'puddleJumper',
                name: 'Puddle Jumper',
                unlocked: false,
                achievementId: 'earned_my_wings',
                unlockDesc: 'Jump over 3 hazards',
                render: (ctx, x, y, radius) => {
                    // White base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Blue gradient on bottom half - rotates with time
                    const rotation = (Date.now() / 1000) * 0.5; // Slow rotation
                    const gradient = ctx.createLinearGradient(
                        x, 
                        y - radius * Math.cos(rotation), 
                        x, 
                        y + radius * Math.cos(rotation)
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    gradient.addColorStop(0.5, 'rgba(100, 180, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(50, 130, 255, 0.8)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Subtle glow on the upward edge
                    const glowGradient = ctx.createRadialGradient(
                        x - radius * 0.3, 
                        y - radius * 0.5, 
                        0, 
                        x - radius * 0.3, 
                        y - radius * 0.5, 
                        radius * 0.8
                    );
                    glowGradient.addColorStop(0, 'rgba(150, 220, 255, 0.6)');
                    glowGradient.addColorStop(0.5, 'rgba(100, 180, 255, 0.2)');
                    glowGradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright highlight
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x - 7, y - 7, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },
            beachBall: {
                id: 'beachBall',
                name: 'Beach Ball',
                unlocked: false,
                achievementId: 'pro_status',
                unlockDesc: 'Earn 10 achievements',
                render: (ctx, x, y, radius) => {
                    // White base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Colorful segments
                    const colors = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#95E1D3', '#F38181'];
                    const segmentAngle = (Math.PI * 2) / colors.length;
                    
                    colors.forEach((color, i) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.arc(x, y, radius, i * segmentAngle, (i + 1) * segmentAngle);
                        ctx.lineTo(x, y);
                        ctx.fill();
                    });
                    
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x - 7, y - 7, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            },
            baseball: {
                id: 'baseball',
                name: 'Baseball',
                unlocked: false,
                achievementId: 'pro_status',
                unlockDesc: 'Earn 10 achievements',
                render: (ctx, x, y, radius) => {
                    // White leather base
                    ctx.fillStyle = '#F5F5DC';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Red stitching (curved lines)
                    ctx.strokeStyle = '#DC143C';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    
                    // Left stitch curve
                    ctx.beginPath();
                    ctx.arc(x - radius * 0.3, y, radius * 0.8, -Math.PI / 4, Math.PI / 4);
                    ctx.stroke();
                    
                    // Right stitch curve
                    ctx.beginPath();
                    ctx.arc(x + radius * 0.3, y, radius * 0.8, Math.PI * 3 / 4, Math.PI * 5 / 4);
                    ctx.stroke();
                    
                    // Stitch marks
                    for (let i = -3; i <= 3; i++) {
                        const angle = (i * Math.PI) / 12;
                        const sx1 = x - radius * 0.3 + Math.cos(angle) * radius * 0.8;
                        const sy1 = y + Math.sin(angle) * radius * 0.8;
                        ctx.beginPath();
                        ctx.moveTo(sx1 - 3, sy1);
                        ctx.lineTo(sx1 + 3, sy1);
                        ctx.stroke();
                        
                        const sx2 = x + radius * 0.3 - Math.cos(angle) * radius * 0.8;
                        const sy2 = y + Math.sin(angle) * radius * 0.8;
                        ctx.beginPath();
                        ctx.moveTo(sx2 - 3, sy2);
                        ctx.lineTo(sx2 + 3, sy2);
                        ctx.stroke();
                    }
                    
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(x - 7, y - 7, radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            metallicGold: {
                id: 'metallicGold',
                name: 'Metallic Gold',
                unlocked: false,
                achievementId: 'ascended_king',
                unlockDesc: 'Earn all 20 achievements',
                render: (ctx, x, y, radius) => {
                    // Gold gradient
                    const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(0.5, '#FFA500');
                    gradient.addColorStop(1, '#B8860B');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    const shineGradient = ctx.createRadialGradient(x - 8, y - 8, 0, x - 8, y - 8, radius * 0.5);
                    shineGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    shineGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                    ctx.fillStyle = shineGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing border
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            metallicSilver: {
                id: 'metallicSilver',
                name: 'Metallic Silver',
                unlocked: false,
                achievementId: 'ascended_king',
                unlockDesc: 'Earn all 20 achievements',
                render: (ctx, x, y, radius) => {
                    // Silver gradient
                    const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
                    gradient.addColorStop(0, '#E8E8E8');
                    gradient.addColorStop(0.5, '#C0C0C0');
                    gradient.addColorStop(1, '#A9A9A9');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    const shineGradient = ctx.createRadialGradient(x - 8, y - 8, 0, x - 8, y - 8, radius * 0.5);
                    shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = shineGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Chrome reflection
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y + radius * 0.3, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing border
                    ctx.strokeStyle = '#E8E8E8';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#C0C0C0';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            legendHasIt: {
                id: 'legendHasIt',
                name: 'Legend Has It...',
                unlocked: false,
                achievementId: 'ascended_king',
                unlockDesc: 'Earn all 20 achievements',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Crown ring around equator
                    const crownPoints = 7;
                    const crownHeight = radius * 0.25;
                    const crownWidth = (Math.PI * 2 * radius) / crownPoints;
                    
                    // Draw crown as a continuous ring
                    ctx.save();
                    
                    // Gold gradient for crown
                    const crownGradient = ctx.createLinearGradient(x, y - crownHeight, x, y + crownHeight);
                    crownGradient.addColorStop(0, '#FFD700');
                    crownGradient.addColorStop(0.5, '#FFA500');
                    crownGradient.addColorStop(1, '#DAA520');
                    
                    // Draw crown points around the equator
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const nextAngle = ((i + 1) * Math.PI * 2) / crownPoints;
                        
                        // Base of crown point
                        const baseX1 = x + Math.cos(angle) * radius;
                        const baseY1 = y + Math.sin(angle) * radius;
                        const baseX2 = x + Math.cos(nextAngle) * radius;
                        const baseY2 = y + Math.sin(nextAngle) * radius;
                        
                        // Tip of crown point (extends outward)
                        const tipAngle = angle + (nextAngle - angle) / 2;
                        const tipX = x + Math.cos(tipAngle) * (radius + crownHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + crownHeight);
                        
                        // Draw triangular crown point
                        ctx.fillStyle = crownGradient;
                        ctx.beginPath();
                        ctx.moveTo(baseX1, baseY1);
                        ctx.lineTo(tipX, tipY);
                        ctx.lineTo(baseX2, baseY2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Golden outline
                        ctx.strokeStyle = '#B8860B';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    
                    // Shimmer effect on crown
                    const shimmerOffset = (Date.now() / 500) % crownPoints;
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const tipAngle = angle + (Math.PI * 2 / crownPoints) / 2;
                        const tipX = x + Math.cos(tipAngle) * (radius + crownHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + crownHeight);
                        
                        const shimmerIntensity = Math.abs(((i + shimmerOffset) % crownPoints) - crownPoints / 2) / (crownPoints / 2);
                        ctx.fillStyle = `rgba(255, 255, 200, ${0.6 * (1 - shimmerIntensity)})`;
                        ctx.beginPath();
                        ctx.arc(tipX, tipY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Ball shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Golden dust trail shimmer
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + crownHeight, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            bronzeSteering: {
                id: 'bronzeSteering',
                name: 'Distracted Driver',
                unlocked: false,
                achievementId: 'distracted_driver',
                unlockDesc: 'Stay in same lane for 5 seconds',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bronze steering wheel across equator
                    const wheelRadius = radius * 0.6;
                    const wheelThickness = radius * 0.15;
                    
                    // Bronze gradient
                    const gradient = ctx.createRadialGradient(x, y, wheelRadius - wheelThickness, x, y, wheelRadius);
                    gradient.addColorStop(0, '#CD7F32');
                    gradient.addColorStop(0.5, '#B87333');
                    gradient.addColorStop(1, '#8B6914');
                    
                    // Outer ring
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = wheelThickness;
                    ctx.beginPath();
                    ctx.arc(x, y, wheelRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Spokes (4 spokes forming a cross)
                    ctx.strokeStyle = '#CD7F32';
                    ctx.lineWidth = radius * 0.08;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI) / 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * wheelRadius, y + Math.sin(angle) * wheelRadius);
                        ctx.stroke();
                    }
                    
                    // Center hub
                    ctx.fillStyle = '#8B6914';
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(x - 6, y - 6, radius * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            silverSteering: {
                id: 'silverSteering',
                name: 'Hands Free',
                unlocked: false,
                achievementId: 'hands_free',
                unlockDesc: 'Stay in same lane for 10 seconds',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Silver steering wheel across equator
                    const wheelRadius = radius * 0.6;
                    const wheelThickness = radius * 0.15;
                    
                    // Silver gradient
                    const gradient = ctx.createRadialGradient(x, y, wheelRadius - wheelThickness, x, y, wheelRadius);
                    gradient.addColorStop(0, '#E8E8E8');
                    gradient.addColorStop(0.5, '#C0C0C0');
                    gradient.addColorStop(1, '#A9A9A9');
                    
                    // Outer ring
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = wheelThickness;
                    ctx.beginPath();
                    ctx.arc(x, y, wheelRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Spokes (4 spokes forming a cross)
                    ctx.strokeStyle = '#E8E8E8';
                    ctx.lineWidth = radius * 0.08;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI) / 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * wheelRadius, y + Math.sin(angle) * wheelRadius);
                        ctx.stroke();
                    }
                    
                    // Center hub
                    ctx.fillStyle = '#A9A9A9';
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 6, y - 6, radius * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Chrome reflection
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y + radius * 0.3, radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            goldSteering: {
                id: 'goldSteering',
                name: 'Autopilot Engaged',
                unlocked: false,
                achievementId: 'autopilot_engaged',
                unlockDesc: 'Stay in same lane for 15 seconds',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gold steering wheel across equator
                    const wheelRadius = radius * 0.6;
                    const wheelThickness = radius * 0.15;
                    
                    // Gold gradient
                    const gradient = ctx.createRadialGradient(x, y, wheelRadius - wheelThickness, x, y, wheelRadius);
                    gradient.addColorStop(0, '#FFD700');
                    gradient.addColorStop(0.5, '#FFA500');
                    gradient.addColorStop(1, '#B8860B');
                    
                    // Outer ring
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = wheelThickness;
                    ctx.beginPath();
                    ctx.arc(x, y, wheelRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Spokes (4 spokes forming a cross)
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = radius * 0.08;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI) / 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * wheelRadius, y + Math.sin(angle) * wheelRadius);
                        ctx.stroke();
                    }
                    
                    // Center hub
                    ctx.fillStyle = '#B8860B';
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metallic shine
                    const shineGradient = ctx.createRadialGradient(x - 8, y - 8, 0, x - 8, y - 8, radius * 0.5);
                    shineGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    shineGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                    ctx.fillStyle = shineGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glowing effect
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 8;
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, wheelRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            fieryCrown: {
                id: 'fieryCrown',
                name: 'Fiery Crown',
                unlocked: false,
                achievementId: 'pyromancer',
                unlockDesc: '1000 lifetime Golden Flames',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fiery crown ring around equator
                    const crownPoints = 8;
                    const crownHeight = radius * 0.3;
                    
                    // Draw crown flames around the equator
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const nextAngle = ((i + 1) * Math.PI * 2) / crownPoints;
                        
                        // Base of crown flame
                        const baseX1 = x + Math.cos(angle) * radius;
                        const baseY1 = y + Math.sin(angle) * radius;
                        const baseX2 = x + Math.cos(nextAngle) * radius;
                        const baseY2 = y + Math.sin(nextAngle) * radius;
                        
                        // Tip of flame (extends outward)
                        const tipAngle = angle + (nextAngle - angle) / 2;
                        const tipX = x + Math.cos(tipAngle) * (radius + crownHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + crownHeight);
                        
                        // Fire gradient for flame
                        const flameGradient = ctx.createLinearGradient(baseX1, baseY1, tipX, tipY);
                        flameGradient.addColorStop(0, '#FF6600');
                        flameGradient.addColorStop(0.5, '#FF3300');
                        flameGradient.addColorStop(1, '#FFD700');
                        
                        // Draw flame point
                        ctx.fillStyle = flameGradient;
                        ctx.beginPath();
                        ctx.moveTo(baseX1, baseY1);
                        ctx.lineTo(tipX, tipY);
                        ctx.lineTo(baseX2, baseY2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Flame outline
                        ctx.strokeStyle = '#FF3300';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Animated flickering effect on flames
                    const flickerOffset = (Date.now() / 100) % crownPoints;
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const tipAngle = angle + (Math.PI * 2 / crownPoints) / 2;
                        const flickerHeight = crownHeight * (0.8 + Math.sin((Date.now() / 200) + i) * 0.2);
                        const tipX = x + Math.cos(tipAngle) * (radius + flickerHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + flickerHeight);
                        
                        const glowIntensity = 0.5 + Math.sin((Date.now() / 300) + i * 0.5) * 0.3;
                        ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity})`;
                        ctx.beginPath();
                        ctx.arc(tipX, tipY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Ball shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Fiery glow
                    ctx.shadowColor = '#FF6600';
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = 'rgba(255, 102, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + crownHeight, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
            kingsCrown: {
                id: 'kingsCrown',
                name: 'Kings Crown',
                unlocked: false,
                achievementId: 'scratch_king',
                unlockDesc: 'Survive 180 seconds',
                render: (ctx, x, y, radius) => {
                    // White cue ball base
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Royal crown with jewels
                    const crownPoints = 5;
                    const crownHeight = radius * 0.28;
                    
                    // Gold gradient for crown
                    const crownGradient = ctx.createLinearGradient(x, y - crownHeight, x, y + crownHeight);
                    crownGradient.addColorStop(0, '#FFD700');
                    crownGradient.addColorStop(0.5, '#FFC107');
                    crownGradient.addColorStop(1, '#DAA520');
                    
                    // Draw crown points around the equator
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const nextAngle = ((i + 1) * Math.PI * 2) / crownPoints;
                        
                        // Base of crown point
                        const baseX1 = x + Math.cos(angle) * radius;
                        const baseY1 = y + Math.sin(angle) * radius;
                        const baseX2 = x + Math.cos(nextAngle) * radius;
                        const baseY2 = y + Math.sin(nextAngle) * radius;
                        
                        // Tip of crown point (extends outward)
                        const tipAngle = angle + (nextAngle - angle) / 2;
                        const tipX = x + Math.cos(tipAngle) * (radius + crownHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + crownHeight);
                        
                        // Draw crown point
                        ctx.fillStyle = crownGradient;
                        ctx.beginPath();
                        ctx.moveTo(baseX1, baseY1);
                        ctx.lineTo(tipX, tipY);
                        ctx.lineTo(baseX2, baseY2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Golden outline
                        ctx.strokeStyle = '#B8860B';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                    
                    // Add jewels at crown tips
                    for (let i = 0; i < crownPoints; i++) {
                        const angle = (i * Math.PI * 2) / crownPoints;
                        const tipAngle = angle + (Math.PI * 2 / crownPoints) / 2;
                        const tipX = x + Math.cos(tipAngle) * (radius + crownHeight);
                        const tipY = y + Math.sin(tipAngle) * (radius + crownHeight);
                        
                        // Jewel colors (ruby red)
                        const jewelGradient = ctx.createRadialGradient(tipX, tipY, 0, tipX, tipY, 5);
                        jewelGradient.addColorStop(0, '#FF1744');
                        jewelGradient.addColorStop(0.5, '#C62828');
                        jewelGradient.addColorStop(1, '#8B0000');
                        
                        ctx.fillStyle = jewelGradient;
                        ctx.beginPath();
                        ctx.arc(tipX, tipY, 5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Jewel shine
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(tipX - 2, tipY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Ball shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x - 8, y - 8, radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Royal glow
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 12;
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + crownHeight, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            },
                measlesBall: {
                id: 'measlesBall',
                name: 'Measles Ball',
                unlocked: false,
                achievementId: 'ascended_king',
                unlockDesc: 'Earn all 20 achievements',
                imagePath: '/skins/Measles-Ball-Skin.gif',
                rotating: false,
                rotationSpeed: 0
            },
            bowlingBall: {
                id: 'bowlingBall',
                name: 'Bowling Ball',
                unlocked: true,
                unlockDesc: 'Available now!',
                imagePath: '/skins/Bowling-Ball-Skin.gif',
                rotating: false,
                rotationSpeed: 0
            },
            fireFlame: {
                id: 'fireFlame',
                name: 'Fire Flame',
                unlocked: false,
                achievementId: 'flaming_crown',
                unlockDesc: 'Collect 30 golden flames',
                imagePath: '/skins/fire-flame.gif',
                rotating: false,
                rotationSpeed: 0
            },
            fireFlame2: {
                id: 'fireFlame2',
                name: 'Fire Flame 2',
                unlocked: false,
                achievementId: 'scratch_king',
                unlockDesc: 'Survive 180 seconds',
                imagePath: '/skins/fire-flame2.gif',
                rotating: false,
                rotationSpeed: 0
            },
            snowflake: {
                id: 'snowflake',
                name: 'Snowflake',
                unlocked: false,
                unlockCondition: () => (musicProgress.gamesPlayed || 0) >= 25,
                unlockDesc: 'Play 25 games',
                imagePath: '/skins/snowflake.gif',
                rotating: false,
                rotationSpeed: 0
            }
        };

        let currentSkin = localStorage.getItem('cueBallSkin') || 'default';

        function isSkinUnlocked(skinId) {
            const skin = CUE_BALL_SKINS[skinId];
            if (!skin) return false;
            if (skin.unlocked) return true;
            // Check games-played unlock condition
            if (skin.unlockCondition && typeof skin.unlockCondition === 'function') {
                return skin.unlockCondition();
            }
            if (!skin.achievementId) return true;
            return achievementsProgress.unlocked.includes(skin.achievementId);
        }

        function selectSkin(skinId) {
            if (!isSkinUnlocked(skinId)) {
                console.log('Skin locked:', skinId);
                return;
            }
            currentSkin = skinId;
            localStorage.setItem('cueBallSkin', skinId);
            renderSkinGrid();
            console.log('Skin selected:', skinId);
        }

        // Image cache for skins
        const skinImageCache = {};

        function loadSkinImage(imagePath) {
            if (skinImageCache[imagePath]) {
                return skinImageCache[imagePath];
            }
            
            const img = new Image();
            img.src = imagePath;
            skinImageCache[imagePath] = img;
            return img;
        }

        function renderPlayerBall(ctx, x, y, radius) {
            const skin = CUE_BALL_SKINS[currentSkin] || CUE_BALL_SKINS.default;
            
            // Check if this is an image-based skin
            if (skin.imagePath) {
                const img = loadSkinImage(skin.imagePath);
                if (img.complete && img.naturalWidth > 0) {
                    // Image loaded successfully - draw it centered on the ball position
                    const diameter = radius * 2;
                    ctx.save();
                    
                    // Optional rotation for rolling effect
                    if (skin.rotating) {
                        ctx.translate(x, y);
                        const rotation = (Date.now() / 1000) * skin.rotationSpeed || 2;
                        ctx.rotate(rotation);
                        ctx.drawImage(img, -radius, -radius, diameter, diameter);
                        ctx.restore();
                    } else {
                        ctx.drawImage(img, x - radius, y - radius, diameter, diameter);
                        ctx.restore();
                    }
                } else {
                    // Image not loaded yet - show default white ball as fallback
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Use procedural rendering
                skin.render(ctx, x, y, radius);
            }
        }

        let skinCarouselIndex = 0;
        const SKINS_PER_PAGE = 3;
        
        function renderSkinGrid() {
            const container = document.getElementById('skinCarouselContainer');
            const indicator = document.getElementById('skinIndicator');
            const prevBtn = document.getElementById('skinPrevBtn');
            const nextBtn = document.getElementById('skinNextBtn');
            
            if (!container) return; // Guard against missing elements
            
            const allSkins = Object.values(CUE_BALL_SKINS);
            const totalPages = Math.ceil(allSkins.length / SKINS_PER_PAGE);
            
            // Ensure index is within bounds
            skinCarouselIndex = Math.max(0, Math.min(skinCarouselIndex, totalPages - 1));
            
            // Clear container
            container.innerHTML = '';
            
            // Get skins for current page
            const startIdx = skinCarouselIndex * SKINS_PER_PAGE;
            const endIdx = Math.min(startIdx + SKINS_PER_PAGE, allSkins.length);
            const skinsToShow = allSkins.slice(startIdx, endIdx);
            
            // Render skins
            skinsToShow.forEach(skin => {
                const unlocked = isSkinUnlocked(skin.id);
                const selected = currentSkin === skin.id;

                const skinItem = document.createElement('div');
                skinItem.className = `skin-item${selected ? ' selected' : ''}${!unlocked ? ' locked' : ''}`;
                skinItem.style.flex = '1';
                skinItem.style.minWidth = '90px';
                
                const canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                
                // Handle image-based skins in preview
                if (skin.imagePath) {
                    const img = loadSkinImage(skin.imagePath);
                    if (img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, 5, 5, 40, 40);
                    } else {
                        // Show placeholder while loading
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(25, 25, 20, 0, Math.PI * 2);
                        ctx.fill();
                        // Retry rendering when image loads
                        img.onload = () => renderSkinGrid();
                    }
                } else {
                    skin.render(ctx, 25, 25, 20);
                }
                canvas.className = 'skin-preview';

                const nameDiv = document.createElement('div');
                nameDiv.className = 'skin-name';
                nameDiv.textContent = skin.name;

                const unlockDiv = document.createElement('div');
                unlockDiv.className = 'skin-unlock';
                unlockDiv.textContent = unlocked ? (selected ? '‚úì Equipped' : 'Unlocked') : `üîí ${skin.unlockDesc}`;

                skinItem.appendChild(canvas);
                skinItem.appendChild(nameDiv);
                skinItem.appendChild(unlockDiv);

                if (unlocked) {
                    let touchedOnce = false;
                    let isHovering = false;
                    
                    // Desktop: Show requirement on hover, equip on click
                    skinItem.addEventListener('mouseenter', () => {
                        isHovering = true;
                        unlockDiv.textContent = `üèÜ ${skin.unlockDesc}`;
                    });
                    
                    skinItem.addEventListener('mouseleave', () => {
                        isHovering = false;
                        touchedOnce = false; // Reset touch state when mouse leaves
                        unlockDiv.textContent = selected ? '‚úì Equipped' : 'Unlocked';
                    });
                    
                    // Mobile: First tap shows requirement, second tap equips
                    skinItem.addEventListener('touchstart', (e) => {
                        if (!touchedOnce) {
                            // First touch: show requirement
                            e.preventDefault();
                            unlockDiv.textContent = `üèÜ ${skin.unlockDesc}`;
                            touchedOnce = true;
                        } else {
                            // Second touch: equip skin
                            selectSkin(skin.id);
                            touchedOnce = false;
                        }
                    });
                    
                    // Desktop click: equip immediately (if hovering, we already show requirement)
                    skinItem.addEventListener('click', (e) => {
                        // Only handle click if it's not a touch event
                        if (!e.touches && isHovering) {
                            selectSkin(skin.id);
                        }
                    });
                }

                container.appendChild(skinItem);
            });
            
            // Update indicator and buttons
            if (indicator) {
                indicator.textContent = `${skinCarouselIndex + 1}/${totalPages}`;
            }
            if (prevBtn) {
                prevBtn.disabled = skinCarouselIndex === 0;
            }
            if (nextBtn) {
                nextBtn.disabled = skinCarouselIndex >= totalPages - 1;
            }
        }
        
        // Carousel navigation handlers
        function setupCarouselNavigation() {
            const prevBtn = document.getElementById('skinPrevBtn');
            const nextBtn = document.getElementById('skinNextBtn');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (skinCarouselIndex > 0) {
                        skinCarouselIndex--;
                        renderSkinGrid();
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    const allSkins = Object.values(CUE_BALL_SKINS);
                    const totalPages = Math.ceil(allSkins.length / SKINS_PER_PAGE);
                    if (skinCarouselIndex < totalPages - 1) {
                        skinCarouselIndex++;
                        renderSkinGrid();
                    }
                });
            }
        }

        // Music selection toggle
        function cycleBackgroundMusic() {
            const unlockedTracks = musicProgress.unlockedTracks || ['classic'];
            const trackIds = Object.keys(BACKGROUND_TRACKS).filter(id => unlockedTracks.includes(id));
            
            if (trackIds.length <= 1) {
                console.log('No other tracks unlocked yet');
                return;
            }
            
            const currentIndex = trackIds.indexOf(musicProgress.currentTrack || 'classic');
            const nextIndex = (currentIndex + 1) % trackIds.length;
            const nextTrackId = trackIds[nextIndex];
            
            switchBackgroundTrack(nextTrackId);
        }

        function switchBackgroundTrack(trackId) {
            const track = BACKGROUND_TRACKS[trackId];
            if (!track || !musicProgress.unlockedTracks.includes(trackId)) {
                console.log('Track not available:', trackId);
                return;
            }
            
            const wasPlaying = !sounds.start.paused;
            const currentTime = sounds.start.currentTime;
            
            stopStartSound();
            
            sounds.start = new Audio(track.file);
            sounds.start.volume = 0.3;
            sounds.start.loop = true;
            sounds.start.muted = audioMuted;
            
            musicProgress.currentTrack = trackId;
            localStorage.setItem('scratchKingMusic', JSON.stringify(musicProgress));
            
            updateMusicText();
            
            if (wasPlaying) {
                playStartSound();
            }
            
            console.log('Switched to track:', track.name);
        }

        function updateMusicText() {
            const musicSelectText = document.getElementById('musicSelectText');
            if (!musicSelectText) return; // Element not loaded yet
            
            const track = BACKGROUND_TRACKS[musicProgress.currentTrack || 'classic'];
            const unlockedCount = musicProgress.unlockedTracks.length;
            const totalTracks = Object.keys(BACKGROUND_TRACKS).length;
            musicSelectText.textContent = `üéµ Music: ${track.name} (${unlockedCount}/${totalTracks})`;
        }

        // ============================================================
        // LANE SYSTEM
        // ============================================================
        // Convert lane index (0, 1, 2) to x-position on canvas
        function getLaneX(laneIndex) {
            const laneWidth = canvas.width / LANE_COUNT;
            return laneWidth * laneIndex + laneWidth / 2;
        }

        function movePlayerLeft() {
            if (playerLane > 0) {
                playerLane--;
                // Reset cruise control timer when changing lanes
                currentLaneStartTime = Date.now();
                console.log('Player moved to lane', playerLane);
            }
        }

        function movePlayerRight() {
            if (playerLane < LANE_COUNT - 1) {
                playerLane++;
                // Reset cruise control timer when changing lanes
                currentLaneStartTime = Date.now();
                console.log('Player moved to lane', playerLane);
            }
        }

        // ============================================================
        // GAME OBJECTS (Obstacles and Collectibles)
        // ============================================================
        let obstacleIdCounter = 0; // Counter for unique obstacle IDs
        
        function spawnObstacle() {
            const lane = Math.floor(Math.random() * LANE_COUNT);
            const ballType = Math.random();
            const obstacleId = obstacleIdCounter++;
            
            if (ballType < 0.4) {
                // Solid ball (40% chance) - straight movement
                const ballData = BALL_COLORS.solids[Math.floor(Math.random() * BALL_COLORS.solids.length)];
                obstacles.push({
                    id: obstacleId,
                    lane: lane,
                    x: getLaneX(lane),
                    y: -OBSTACLE_RADIUS,
                    type: 'solid',
                    color: ballData.color,
                    number: ballData.number,
                    movementType: 'normal',
                    direction: 0,
                    zigzagPhase: 0,
                    speed: gameSpeed
                });
            } else if (ballType < 0.7) {
                // Striped ball (30% chance) - straight movement
                const ballData = BALL_COLORS.striped[Math.floor(Math.random() * BALL_COLORS.striped.length)];
                obstacles.push({
                    id: obstacleId,
                    lane: lane,
                    x: getLaneX(lane),
                    y: -OBSTACLE_RADIUS,
                    type: 'striped',
                    color: ballData.color,
                    number: ballData.number,
                    movementType: 'normal',
                    direction: 0,
                    zigzagPhase: 0,
                    speed: gameSpeed
                });
            } else {
                // 8-ball (30% chance) - zigzag movement
                const direction = (Math.random() > 0.5) ? 1 : -1;
                obstacles.push({
                    id: obstacleId,
                    lane: lane,
                    x: getLaneX(lane),
                    y: -OBSTACLE_RADIUS,
                    type: '8ball',
                    movementType: 'zigzag',
                    direction: direction,
                    zigzagPhase: 0,
                    speed: gameSpeed
                });
            }
        }

        function spawnCollectible() {
            const lane = Math.floor(Math.random() * LANE_COUNT);
            collectibles.push({
                lane: lane,
                y: -COLLECTIBLE_RADIUS,
                scale: 1
            });
        }

        function spawnPowerUp() {
            const lane = Math.floor(Math.random() * LANE_COUNT);
            powerUps.push({
                lane: lane,
                y: -30,
                type: 'jumpman'
            });
        }

        // Spawn items based on difficulty
        function spawnItems(currentTime) {
            if (currentTime - lastSpawnTime > spawnInterval) {
                // 70% chance obstacle, 30% chance collectible
                if (Math.random() < 0.7) {
                    spawnObstacle();
                } else {
                    spawnCollectible();
                }
                lastSpawnTime = currentTime;
            }

            // Spawn power-ups periodically
            if (currentTime - lastPowerUpSpawn > POWERUP_SPAWN_INTERVAL && powerUps.length === 0) {
                spawnPowerUp();
                lastPowerUpSpawn = currentTime;
            }
        }

        // ============================================================
        // COLLISION DETECTION
        // ============================================================
        // Simple circle-to-circle collision using radius
        function checkCollision(x1, y1, r1, x2, y2, r2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (r1 + r2);
        }

        // ============================================================
        // GAME LOOP
        // ============================================================
        function resetGame() {
            playerLane = 1;
            score = 0;
            obstacles = [];
            collectibles = [];
            particles = [];
            playerTrail = [];
            combo = 0;
            lastCollectTime = 0;
            powerUps = [];
            jumpManActive = false;
            playerJumpOffset = 0;
            lastPowerUpSpawn = 0;
            bonusTime = 0;
            scrollOffset = 0;
            gameSpeed = INITIAL_SPEED;
            spawnInterval = INITIAL_SPAWN_INTERVAL;
            lastSpawnTime = 0;
            gameStartTime = Date.now();
            achievementsProgress.flamesThisRun = 0; // Reset flames for this run
            
            // Reset game statistics
            nearMisses = 0;
            flamesCollected = 0;
            pixelsScrolled = 0;
            totalAirTimeMs = 0;
            
            // Reset jump tracking
            jumpsThisRun = 0;
            hazardsJumpedThisRun = 0;
            trackedObstacles.clear();
            obstacleIdCounter = 0;
            previousJumpOffset = 0;
            hasLandedThisJump = true;
            
            // Reset cruise control tracking
            currentLaneStartTime = Date.now();
            maxTimeInSameLane = 0;
            
            console.log('Game reset, starting fresh');
        }

        function updateGame() {
            if (gameState !== 'playing') return;

            const currentTime = Date.now() - gameStartTime + bonusTime;

            // Update timer display
            const totalSeconds = Math.floor(currentTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            document.getElementById('runTimer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Add time-based score (1 point per second)
            score += 0.016; // Approximately 1 point per second at 60fps

            // Update cruise control tracking (time in same lane)
            const timeInCurrentLane = (Date.now() - currentLaneStartTime) / 1000; // in seconds
            if (timeInCurrentLane > maxTimeInSameLane) {
                maxTimeInSameLane = timeInCurrentLane;
            }

            // Check for achievements
            checkAchievements(currentTime);

            // Increase difficulty over time
            gameSpeed = Math.min(INITIAL_SPEED + (currentTime * SPEED_INCREMENT), MAX_SPEED);
            spawnInterval = Math.max(
                INITIAL_SPAWN_INTERVAL - (currentTime * SPAWN_DECREASE_RATE), 
                MIN_SPAWN_INTERVAL
            );

            // Update scroll offset and distance traveled
            scrollOffset += gameSpeed;
            pixelsScrolled += gameSpeed;

            // Spawn new items
            spawnItems(currentTime);

            // Update and check obstacles
            const playerX = getLaneX(playerLane);
            const playerY = canvas.height - 150;

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += gameSpeed;

                // Apply movement pattern
                if (obs.movementType === 'diagonal') {
                    obs.x += obs.direction * 1.5;
                } else if (obs.movementType === 'zigzag') {
                    obs.zigzagPhase += 0.1;
                    obs.x = getLaneX(obs.lane) + Math.sin(obs.zigzagPhase) * 40 * obs.direction;
                }

                // Check collision with player (use actual x position for moving obstacles)
                const obsX = obs.x || getLaneX(obs.lane);
                const effectivePlayerY = playerY + playerJumpOffset;
                
                // Skip ALL collisions when Jump Man is active (player comfort mechanic)
                if (!jumpManActive && checkCollision(playerX, effectivePlayerY, PLAYER_RADIUS, obsX, obs.y, OBSTACLE_RADIUS)) {
                    createExplosion(playerX, effectivePlayerY, '#d11111');
                    endGame();
                    return;
                }
                
                // Track near misses (within 1.5x collision distance but not colliding)
                const nearMissDistance = (PLAYER_RADIUS + OBSTACLE_RADIUS) * 1.5;
                const distance = Math.sqrt((playerX - obsX) ** 2 + (effectivePlayerY - obs.y) ** 2);
                if (!jumpManActive && distance < nearMissDistance && distance > (PLAYER_RADIUS + OBSTACLE_RADIUS)) {
                    if (!obs.nearMissCounted) {
                        nearMisses++;
                        obs.nearMissCounted = true;
                    }
                }
                
                // Track hazards jumped over when Jump Man is active
                if (jumpManActive && obs.y > playerY && !trackedObstacles.has(obs.id)) {
                    // Obstacle has passed below the player while jumping
                    hazardsJumpedThisRun++;
                    trackedObstacles.add(obs.id);
                    console.log('Jumped over hazard! Total:', hazardsJumpedThisRun);
                }

                // Remove if off screen (check both vertical and horizontal)
                if (obs.y > canvas.height + OBSTACLE_RADIUS || 
                    obsX < -OBSTACLE_RADIUS || 
                    obsX > canvas.width + OBSTACLE_RADIUS) {
                    obstacles.splice(i, 1);
                }
            }

            // Update and check collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const col = collectibles[i];
                col.y += gameSpeed;

                const colX = getLaneX(col.lane);
                const effectivePlayerY = playerY + playerJumpOffset;
                
                // Check if would collide with grounded cue ball (for auto-collect during jump)
                const wouldCollideGrounded = jumpManActive && checkCollision(playerX, playerY, PLAYER_RADIUS, colX, col.y, COLLECTIBLE_RADIUS);
                
                // Check collection: either normal collection or auto-collect during jump
                if (!jumpManActive && checkCollision(playerX, effectivePlayerY, PLAYER_RADIUS, colX, col.y, COLLECTIBLE_RADIUS)) {
                    const currentTime = Date.now();
                    
                    // Update combo
                    if (currentTime - lastCollectTime < COMBO_TIMEOUT) {
                        combo++;
                    } else {
                        combo = 1;
                    }
                    lastCollectTime = currentTime;
                    
                    // Calculate score with combo multiplier
                    const multiplier = Math.min(combo, 5); // Max 5x multiplier
                    const points = COLLECTIBLE_POINTS * multiplier;
                    score += points;
                    
                    // Track Golden Flames for achievements
                    achievementsProgress.flamesThisRun = (achievementsProgress.flamesThisRun || 0) + 1;
                    achievementsProgress.flamesLifetime = (achievementsProgress.flamesLifetime || 0) + 1;
                    localStorage.setItem('scratchKingAchievements', JSON.stringify(achievementsProgress));
                    
                    // Track flames collected for stats
                    flamesCollected++;
                    
                    createCollectParticles(colX, col.y);
                    playCollectSound();
                    collectibles.splice(i, 1);
                    console.log(`Collected! Combo: ${combo}x, Points: ${points}, Total Score: ${Math.floor(score)}`);
                    continue;
                } else if (wouldCollideGrounded) {
                    // Auto-collect flames during jump if they would have collided with grounded cue ball
                    const currentTime = Date.now();
                    
                    // Update combo
                    if (currentTime - lastCollectTime < COMBO_TIMEOUT) {
                        combo++;
                    } else {
                        combo = 1;
                    }
                    lastCollectTime = currentTime;
                    
                    // Calculate score with combo multiplier
                    const multiplier = Math.min(combo, 5); // Max 5x multiplier
                    const points = COLLECTIBLE_POINTS * multiplier;
                    score += points;
                    
                    // Track Golden Flames for achievements
                    achievementsProgress.flamesThisRun = (achievementsProgress.flamesThisRun || 0) + 1;
                    achievementsProgress.flamesLifetime = (achievementsProgress.flamesLifetime || 0) + 1;
                    localStorage.setItem('scratchKingAchievements', JSON.stringify(achievementsProgress));
                    
                    // Track flames collected for stats
                    flamesCollected++;
                    
                    createCollectParticles(colX, col.y);
                    playCollectSound();
                    collectibles.splice(i, 1);
                    console.log(`Auto-collected during jump! Combo: ${combo}x, Points: ${points}, Total Score: ${Math.floor(score)}`);
                    continue;
                }

                // Remove if off screen
                if (col.y > canvas.height + COLLECTIBLE_RADIUS) {
                    collectibles.splice(i, 1);
                }
            }

            // Update and check power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                pu.y += gameSpeed;

                // Check collection (use effective Y position with jump offset)
                const puX = getLaneX(pu.lane);
                const effectivePlayerY = playerY + playerJumpOffset;
                if (checkCollision(playerX, effectivePlayerY, PLAYER_RADIUS, puX, pu.y, 25)) {
                    jumpManActive = true;
                    jumpManDuration = Date.now();
                    bonusTime += POWERUP_BONUS_TIME;
                    jumpsThisRun++; // Track total jumps for achievements
                    powerUps.splice(i, 1);
                    playCollectSound();
                    console.log('Jump Man activated! Total jumps:', jumpsThisRun);
                    continue;
                }

                // Remove if off screen
                if (pu.y > canvas.height + 30) {
                    powerUps.splice(i, 1);
                }
            }

            // Handle Jump Man power-up
            if (jumpManActive) {
                const elapsed = Date.now() - jumpManDuration;
                if (elapsed > JUMP_MAN_TIME) {
                    jumpManActive = false;
                    playerJumpOffset = 0;
                } else {
                    // Animate jump (sine wave pattern) - increased height and smoother motion for comfort
                    playerJumpOffset = Math.abs(Math.sin((elapsed / JUMP_MAN_TIME) * Math.PI * 4)) * -100;
                    // Track air time (add frame time, approximately 16.67ms at 60fps)
                    totalAirTimeMs += 16.67;
                    
                    // Reset landing flag when ball is jumping
                    if (playerJumpOffset < -10) {
                        hasLandedThisJump = false;
                    }
                }
            }

            // Detect landing for Puddle Jumper splash effect (one-shot per landing)
            const isPuddleJumperActive = CUE_BALL_SKINS.puddleJumper.unlocked && currentSkin === 'puddleJumper';
            if (isPuddleJumperActive && !hasLandedThisJump && previousJumpOffset < -10 && playerJumpOffset >= -5) {
                // Ball just landed (went from jumping to ground)
                const playerX = getLaneX(playerLane);
                const landingY = canvas.height - 150;
                createSplashParticles(playerX, landingY);
                hasLandedThisJump = true; // Prevent retriggering until next jump
            }
            previousJumpOffset = playerJumpOffset;

            // Increase score for distance
            score += DISTANCE_POINTS_PER_FRAME;

            // Check combo timeout
            if (combo > 0 && Date.now() - lastCollectTime > COMBO_TIMEOUT) {
                combo = 0;
            }

            // Update particles
            updateParticles();

            // Update player trail
            updatePlayerTrail(playerX, playerY + playerJumpOffset);

            // Update HUD
            document.getElementById('currentScore').textContent = Math.floor(score);
        }

        function renderGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get current felt/theme colors
            const felt = FELT_COLORS[currentFeltColor] || FELT_COLORS.default;
            const isSkyZaddy = isSkyZaddyActive();

            // Draw pool table background with gradient and felt texture
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, felt.primary);
            gradient.addColorStop(1, felt.secondary);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add subtle horizontal lines for felt texture effect
            ctx.strokeStyle = isSkyZaddy ? 'rgba(255, 215, 0, 0.02)' : 'rgba(0, 0, 0, 0.02)';
            ctx.lineWidth = 1;
            for (let y = 0; y < canvas.height; y += 8) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Sky Zaddy theme: Add gold filigree between lanes
            if (isSkyZaddy) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.lineWidth = 2;
                
                // Draw elegant filigree lines between lanes
                const lane1X = getLaneX(0) + LANE_WIDTH / 2;
                const lane2X = getLaneX(1) + LANE_WIDTH / 2;
                
                // Left filigree
                ctx.beginPath();
                ctx.setLineDash([10, 5]);
                ctx.moveTo(lane1X, 0);
                ctx.lineTo(lane1X, canvas.height);
                ctx.stroke();
                
                // Right filigree
                ctx.beginPath();
                ctx.moveTo(lane2X, 0);
                ctx.lineTo(lane2X, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Add decorative dots along the filigree
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                for (let y = 20; y < canvas.height; y += 40) {
                    ctx.beginPath();
                    ctx.arc(lane1X, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(lane2X, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw lane dividers (faint dashed lines)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 15]);
            
            for (let i = 1; i < LANE_COUNT; i++) {
                const x = (canvas.width / LANE_COUNT) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw obstacles (solid, striped, and 8-balls)
            obstacles.forEach(obs => {
                const x = obs.x || getLaneX(obs.lane);
                
                if (obs.type === 'solid') {
                    // Draw solid ball
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    // White circle for number
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Number
                    ctx.fillStyle = obs.color;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(obs.number, x, obs.y);

                    // Shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x - 7, obs.y - 7, OBSTACLE_RADIUS * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obs.type === 'striped') {
                    // Draw striped ball with horizontal equator band
                    // Base color
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    // White horizontal band around equator
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS, 0, Math.PI * 2);
                    ctx.clip();
                    
                    ctx.fillStyle = 'white';
                    const bandHeight = OBSTACLE_RADIUS * 0.6;
                    ctx.fillRect(x - OBSTACLE_RADIUS, obs.y - bandHeight / 2, OBSTACLE_RADIUS * 2, bandHeight);
                    ctx.restore();

                    // White circle for number
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Number
                    ctx.fillStyle = obs.color;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(obs.number, x, obs.y);

                    // Shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x - 7, obs.y - 7, OBSTACLE_RADIUS * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obs.type === '8ball') {
                    // Draw 8-ball (black ball with white circle and number 8)
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();

                    // White circle for number
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(x, obs.y, OBSTACLE_RADIUS * 0.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Number 8
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('8', x, obs.y);

                    // Shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x - 7, obs.y - 7, OBSTACLE_RADIUS * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw collectibles (flame icon)
            collectibles.forEach(col => {
                const x = getLaneX(col.lane);
                const time = Date.now() / 100;
                const flicker1 = Math.sin(time) * 2;
                const flicker2 = Math.sin(time * 1.5) * 1.5;
                const flicker3 = Math.sin(time * 2) * 1;
                
                // Pulsing glow effect
                const pulse = Math.sin(Date.now() / 150) * 0.2 + 0.8;
                const glow = ctx.createRadialGradient(x, col.y, 0, x, col.y, COLLECTIBLE_RADIUS * 3 * pulse);
                glow.addColorStop(0, `rgba(255, 215, 0, ${0.6 * pulse})`);
                glow.addColorStop(0.5, `rgba(255, 100, 0, ${0.3 * pulse})`);
                glow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, col.y, COLLECTIBLE_RADIUS * 3 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Outer red flame layer
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.moveTo(x, col.y + COLLECTIBLE_RADIUS);
                ctx.bezierCurveTo(
                    x - COLLECTIBLE_RADIUS * 0.8, col.y + COLLECTIBLE_RADIUS * 0.3,
                    x - COLLECTIBLE_RADIUS * 0.6 + flicker1, col.y - COLLECTIBLE_RADIUS * 0.5,
                    x + flicker3, col.y - COLLECTIBLE_RADIUS * 1.3
                );
                ctx.bezierCurveTo(
                    x + COLLECTIBLE_RADIUS * 0.6 - flicker2, col.y - COLLECTIBLE_RADIUS * 0.5,
                    x + COLLECTIBLE_RADIUS * 0.8, col.y + COLLECTIBLE_RADIUS * 0.3,
                    x, col.y + COLLECTIBLE_RADIUS
                );
                ctx.closePath();
                ctx.fill();

                // Middle orange flame layer
                ctx.fillStyle = '#FF8C00';
                ctx.beginPath();
                ctx.moveTo(x, col.y + COLLECTIBLE_RADIUS * 0.7);
                ctx.bezierCurveTo(
                    x - COLLECTIBLE_RADIUS * 0.6, col.y + COLLECTIBLE_RADIUS * 0.2,
                    x - COLLECTIBLE_RADIUS * 0.4 + flicker2, col.y - COLLECTIBLE_RADIUS * 0.3,
                    x - flicker1, col.y - COLLECTIBLE_RADIUS * 1.1
                );
                ctx.bezierCurveTo(
                    x + COLLECTIBLE_RADIUS * 0.4 - flicker3, col.y - COLLECTIBLE_RADIUS * 0.3,
                    x + COLLECTIBLE_RADIUS * 0.6, col.y + COLLECTIBLE_RADIUS * 0.2,
                    x, col.y + COLLECTIBLE_RADIUS * 0.7
                );
                ctx.closePath();
                ctx.fill();

                // Inner yellow flame core
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.moveTo(x, col.y + COLLECTIBLE_RADIUS * 0.4);
                ctx.bezierCurveTo(
                    x - COLLECTIBLE_RADIUS * 0.4, col.y,
                    x - COLLECTIBLE_RADIUS * 0.3 - flicker3, col.y - COLLECTIBLE_RADIUS * 0.2,
                    x + flicker2, col.y - COLLECTIBLE_RADIUS * 0.8
                );
                ctx.bezierCurveTo(
                    x + COLLECTIBLE_RADIUS * 0.3 + flicker1, col.y - COLLECTIBLE_RADIUS * 0.2,
                    x + COLLECTIBLE_RADIUS * 0.4, col.y,
                    x, col.y + COLLECTIBLE_RADIUS * 0.4
                );
                ctx.closePath();
                ctx.fill();

                // Bright white-yellow core highlight
                ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                ctx.beginPath();
                ctx.moveTo(x, col.y + COLLECTIBLE_RADIUS * 0.2);
                ctx.bezierCurveTo(
                    x - COLLECTIBLE_RADIUS * 0.2, col.y - COLLECTIBLE_RADIUS * 0.1,
                    x - COLLECTIBLE_RADIUS * 0.15, col.y - COLLECTIBLE_RADIUS * 0.3,
                    x, col.y - COLLECTIBLE_RADIUS * 0.5
                );
                ctx.bezierCurveTo(
                    x + COLLECTIBLE_RADIUS * 0.15, col.y - COLLECTIBLE_RADIUS * 0.3,
                    x + COLLECTIBLE_RADIUS * 0.2, col.y - COLLECTIBLE_RADIUS * 0.1,
                    x, col.y + COLLECTIBLE_RADIUS * 0.2
                );
                ctx.closePath();
                ctx.fill();

                // Sparkle particles around flame
                const sparkleCount = 4;
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (Date.now() / 800 + i * (Math.PI * 2) / sparkleCount) % (Math.PI * 2);
                    const dist = COLLECTIBLE_RADIUS * 1.8;
                    const sparkleX = x + Math.cos(angle) * dist;
                    const sparkleY = col.y + Math.sin(angle) * dist * 0.8;
                    const sparkleSize = 2 + Math.sin(Date.now() / 100 + i) * 1;
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.6 + Math.sin(Date.now() / 150 + i) * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw power-ups
            powerUps.forEach(pu => {
                const x = getLaneX(pu.lane);
                
                // Strong pulsing golden glow (very distinctive)
                const pulse = Math.sin(Date.now() / 200) * 0.4 + 0.8;
                const glow = ctx.createRadialGradient(x, pu.y, 0, x, pu.y, 50 * pulse);
                glow.addColorStop(0, 'rgba(255, 215, 0, 1)');
                glow.addColorStop(0.5, 'rgba(255, 165, 0, 0.6)');
                glow.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, pu.y, 50 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Rotating star shape for Jump Man (golden with orange gradient)
                const rotation = (Date.now() / 1000) % (Math.PI * 2);
                const starGradient = ctx.createRadialGradient(x, pu.y, 0, x, pu.y, 28);
                starGradient.addColorStop(0, '#FFD700');
                starGradient.addColorStop(1, '#FFA500');
                ctx.fillStyle = starGradient;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2 + rotation;
                    const radius = i % 2 === 0 ? 28 : 14;
                    const px = x + Math.cos(angle) * radius;
                    const py = pu.y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                
                // White border for contrast
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Inner glow for depth
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(x, pu.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // "J" text (black on white for maximum readability)
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('J', x, pu.y);
            });

            // Draw player trail
            renderPlayerTrail();

            // Draw player (white cue ball)
            const playerX = getLaneX(playerLane);
            const playerY = canvas.height - 150 + playerJumpOffset;

            // Shadow (always on ground)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(playerX, canvas.height - 150 + PLAYER_RADIUS + 5, PLAYER_RADIUS * 0.8, PLAYER_RADIUS * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Sky Zaddy theme: Crown watermark during jumps
            if (isSkyZaddy && jumpManActive) {
                ctx.save();
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = '#FFD700';
                
                // Draw crown shape behind player
                const crownSize = PLAYER_RADIUS * 2.5;
                const crownY = playerY;
                
                ctx.beginPath();
                ctx.moveTo(playerX - crownSize * 0.6, crownY);
                ctx.lineTo(playerX - crownSize * 0.4, crownY - crownSize * 0.5);
                ctx.lineTo(playerX - crownSize * 0.2, crownY - crownSize * 0.2);
                ctx.lineTo(playerX, crownY - crownSize * 0.7);
                ctx.lineTo(playerX + crownSize * 0.2, crownY - crownSize * 0.2);
                ctx.lineTo(playerX + crownSize * 0.4, crownY - crownSize * 0.5);
                ctx.lineTo(playerX + crownSize * 0.6, crownY);
                ctx.lineTo(playerX + crownSize * 0.5, crownY + crownSize * 0.1);
                ctx.lineTo(playerX - crownSize * 0.5, crownY + crownSize * 0.1);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // Sky Zaddy theme: Golden arc at apex of jump
            if (isSkyZaddy && jumpManActive && playerJumpOffset < -80) {
                // Draw golden arc above player at apex
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                const arcRadius = PLAYER_RADIUS * 2;
                ctx.arc(playerX, playerY - PLAYER_RADIUS - 10, arcRadius, 0.3 * Math.PI, 0.7 * Math.PI);
                ctx.stroke();
                
                ctx.restore();
            }

            // Jump Man aura if active
            if (jumpManActive) {
                const auraGlow = ctx.createRadialGradient(playerX, playerY, 0, playerX, playerY, PLAYER_RADIUS * 2);
                auraGlow.addColorStop(0, 'rgba(0, 200, 255, 0.4)');
                auraGlow.addColorStop(1, 'rgba(0, 200, 255, 0)');
                ctx.fillStyle = auraGlow;
                ctx.beginPath();
                ctx.arc(playerX, playerY, PLAYER_RADIUS * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player ball (using selected skin)
            renderPlayerBall(ctx, playerX, playerY, PLAYER_RADIUS);

            // Draw particles on top
            renderParticles();

            // Draw combo counter if active
            if (combo > 1) {
                const multiplier = Math.min(combo, 5);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 60, 80, 120, 50);
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${multiplier}x COMBO!`, canvas.width / 2, 105);
                
                // Combo timer bar
                const timeLeft = COMBO_TIMEOUT - (Date.now() - lastCollectTime);
                const barWidth = Math.max(0, (timeLeft / COMBO_TIMEOUT) * 100);
                ctx.fillStyle = '#d11111';
                ctx.fillRect(canvas.width / 2 - 50, 125, barWidth, 4);
            }

            // Draw Jump Man timer if active
            if (jumpManActive) {
                const elapsed = Date.now() - jumpManDuration;
                const timeLeft = JUMP_MAN_TIME - elapsed;
                const yPos = combo > 1 ? 150 : 80;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width / 2 - 70, yPos, 140, 50);
                
                ctx.fillStyle = '#00CCFF';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('JUMP MAN!', canvas.width / 2, yPos + 20);
                
                // Timer bar
                const barWidth = Math.max(0, (timeLeft / JUMP_MAN_TIME) * 120);
                ctx.fillStyle = '#00CCFF';
                ctx.fillRect(canvas.width / 2 - 60, yPos + 35, barWidth, 5);
            }
        }

        function gameLoop() {
            updateGame();
            renderGame();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // GAME STATE MANAGEMENT
        // ============================================================
        function startGame() {
            console.log('Starting game...');
            gameState = 'playing';
            resetGame();
            
            // Stop game over voice if it's playing
            if (sounds.gameOverVoice) {
                sounds.gameOverVoice.pause();
                sounds.gameOverVoice.currentTime = 0;
            }
            
            // Hide all overlays including game over screen
            document.getElementById('gameOver').classList.remove('active');
            document.getElementById('tutorialModal').classList.remove('active');
            document.getElementById('settingsMenu').classList.remove('active');
            document.getElementById('pauseOverlay').classList.remove('active');
            document.getElementById('shareScoreBtn').style.display = 'none';
            
            // Show HUD, settings and pause buttons
            document.getElementById('hud').classList.add('active');
            document.getElementById('settingsBtn').classList.add('active');
            document.getElementById('pauseBtn').classList.add('active');
            document.getElementById('highScore').textContent = Math.floor(highScore);
            
            playStartSound();
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameLoop();
        }

        function endGame() {
            console.log('Game over! Final score:', Math.floor(score));
            gameState = 'gameOver';
            
            // Increment games played counter for unlock tracking
            incrementGamesPlayed();
            
            playScratchSound();
            stopStartSound();
            
            // Play game over voice if unlocked (10 games played)
            setTimeout(() => {
                playGameOverVoice();
            }, 500);
            
            // Shake effect
            canvas.classList.add('shake');
            setTimeout(() => canvas.classList.remove('shake'), 300);
            
            // Try haptic feedback on mobile
            if (navigator.vibrate) {
                navigator.vibrate(200);
            }
            
            // Hide HUD, settings and pause buttons
            document.getElementById('hud').classList.remove('active');
            document.getElementById('settingsBtn').classList.remove('active');
            document.getElementById('pauseBtn').classList.remove('active');
            
            // Show screenshot button
            document.getElementById('shareScoreBtn').style.display = 'inline-block';
            
            // Update high score
            const finalScore = Math.floor(score);
            if (finalScore > highScore) {
                highScore = finalScore;
                localStorage.setItem('scratchKingHighScore', highScore);
            }
            
            // Check if score qualifies for leaderboard (top 10 or leaderboard has < 10 entries)
            const qualifiesForLeaderboard = leaderboard.length < 10 || 
                (leaderboard.length > 0 && finalScore >= leaderboard[leaderboard.length - 1].score);
            
            if (qualifiesForLeaderboard) {
                document.getElementById('initialsPrompt').style.display = 'block';
                document.getElementById('initialsInput').value = '';
                setTimeout(() => {
                    document.getElementById('initialsInput').focus();
                }, 300);
            } else {
                document.getElementById('initialsPrompt').style.display = 'none';
            }
            
            // Calculate elapsed time
            const elapsedMs = Date.now() - gameStartTime + bonusTime;
            const elapsedSeconds = Math.floor(elapsedMs / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Calculate distance traveled in inches and mm
            const inchesPerPixel = CUE_BALL_DIAMETER_INCHES / CUE_BALL_DIAMETER_PIXELS;
            const mmPerPixel = CUE_BALL_DIAMETER_MM / CUE_BALL_DIAMETER_PIXELS;
            const distanceInches = pixelsScrolled * inchesPerPixel;
            const distanceMm = pixelsScrolled * mmPerPixel;
            const distanceFeet = distanceInches / 12;
            
            // Format distance display
            let distanceString;
            if (distanceFeet >= 1) {
                distanceString = `${distanceFeet.toFixed(1)}' (${distanceInches.toFixed(0)}")`;
            } else {
                distanceString = `${distanceInches.toFixed(1)}" (${distanceMm.toFixed(0)}mm)`;
            }
            
            // Calculate air time in seconds
            const airTimeSeconds = (totalAirTimeMs / 1000).toFixed(1);
            
            // Show game over screen with all stats
            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('finalTime').textContent = timeString;
            document.getElementById('finalFlames').textContent = flamesCollected;
            document.getElementById('finalNearMisses').textContent = nearMisses;
            document.getElementById('finalJumpedBalls').textContent = hazardsJumpedThisRun;
            document.getElementById('finalAirTime').textContent = `${airTimeSeconds}s`;
            document.getElementById('finalDistance').textContent = distanceString;
            updateLeaderboard();
            document.getElementById('gameOver').classList.add('active');
            
            // Cancel animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }

        function returnToMenu() {
            console.log('Returning to menu - reloading page');
            // Reload page to show splash screen again
            window.location.reload();
        }

        // ============================================================
        // LEADERBOARD
        // ============================================================
        function updateLeaderboard() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            
            // Show top 3
            const topScores = leaderboard.slice(0, 3);
            topScores.forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                div.innerHTML = `
                    <span>${index + 1}. ${entry.initials}</span>
                    <span>${entry.score} ${entry.time ? `(${entry.time})` : ''}</span>
                `;
                list.appendChild(div);
            });
            
            if (topScores.length === 0) {
                list.innerHTML = '<p style="color: #666; text-align: center;">No scores yet</p>';
            }
        }

        function submitInitials() {
            const initials = document.getElementById('initialsInput').value.toUpperCase().trim();
            if (initials.length === 3) {
                // Get the time from the game over screen
                const timeText = document.getElementById('finalTime').textContent;
                
                leaderboard.push({
                    initials: initials,
                    score: Math.floor(score),
                    time: timeText
                });
                // Sort by score descending
                leaderboard.sort((a, b) => b.score - a.score);
                // Keep only top 10
                leaderboard = leaderboard.slice(0, 10);
                localStorage.setItem('scratchKingLeaderboard', JSON.stringify(leaderboard));
                
                document.getElementById('initialsPrompt').style.display = 'none';
                updateLeaderboard();
            }
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;
            
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                movePlayerLeft();
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                movePlayerRight();
            }
        });

        // Touch gesture support (swipe and tap)
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Calculate total movement distance
            const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // If it's a swipe (significant movement)
            if (totalMovement > SWIPE_THRESHOLD) {
                // Check if horizontal swipe (and not vertical)
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 0) {
                        movePlayerRight();
                    } else {
                        movePlayerLeft();
                    }
                }
            } else {
                // It's a tap (minimal movement) - check which half of screen was tapped
                const screenWidth = canvas.width;
                const screenCenterX = screenWidth / 2;
                
                if (touchEndX < screenCenterX) {
                    // Tapped left half - move left
                    movePlayerLeft();
                } else {
                    // Tapped right half - move right
                    movePlayerRight();
                }
            }
        }, { passive: true });

        // Menu buttons
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
        document.getElementById('backToMenuBtn').addEventListener('click', returnToMenu);
        document.getElementById('submitInitials').addEventListener('click', submitInitials);
        
        // Submit initials on Enter key
        document.getElementById('initialsInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitInitials();
            }
        });

        // ============================================================
        // TUTORIAL SYSTEM
        // ============================================================
        let currentTutorialSlide = 0;
        const tutorialSlides = document.querySelectorAll('.tutorial-slide');
        const tutorialDots = document.querySelectorAll('.tutorial-dot');

        function showTutorial() {
            document.getElementById('tutorialModal').classList.add('active');
            currentTutorialSlide = 0;
            updateTutorialSlide();
        }

        function closeTutorial() {
            document.getElementById('tutorialModal').classList.remove('active');
            localStorage.setItem('scratchKingTutorialShown', 'true');
            startGame();
        }

        function updateTutorialSlide() {
            tutorialSlides.forEach((slide, index) => {
                slide.classList.toggle('active', index === currentTutorialSlide);
            });
            tutorialDots.forEach((dot, index) => {
                dot.classList.toggle('active', index === currentTutorialSlide);
            });

            // Update navigation buttons
            const prevBtn = document.getElementById('tutorialPrev');
            const nextBtn = document.getElementById('tutorialNext');
            const achievementsBtn = document.getElementById('tutorialViewAchievements');
            
            prevBtn.style.display = currentTutorialSlide > 0 ? 'block' : 'none';
            achievementsBtn.style.display = currentTutorialSlide === tutorialSlides.length - 1 ? 'inline-block' : 'none';
            nextBtn.textContent = currentTutorialSlide === tutorialSlides.length - 1 ? 'Start Playing!' : 'Next';
        }

        // Track where achievements was opened from
        let achievementsOpenedFrom = null;

        // Hidden unlocks (dev secret)
        const HIDDEN_UNLOCKS = {
            game_over_voice: {
                id: 'game_over_voice',
                name: 'üé§ Scratch King Voice Over',
                desc: 'Complete 10 games to unlock',
                unlockCondition: () => (musicProgress.gamesPlayed || 0) >= 10,
                reward: 'Hidden audio that plays on game over screen'
            }
        };

        let hiddenUnlocksRevealed = false;

        // Shake gesture detection
        let shakeStartTime = null;
        let lastShakeTime = 0;
        const SHAKE_THRESHOLD = 15;
        const SHAKE_DURATION = 3000;

        function handleShake(event) {
            if (!document.getElementById('achievementsPage').classList.contains('active')) {
                shakeStartTime = null;
                return;
            }

            const acceleration = event.accelerationIncludingGravity;
            const current = Math.abs(acceleration.x) + Math.abs(acceleration.y) + Math.abs(acceleration.z);
            
            if (current > SHAKE_THRESHOLD) {
                const now = Date.now();
                
                if (shakeStartTime === null) {
                    shakeStartTime = now;
                }
                
                lastShakeTime = now;
                
                // If shaking continuously for 3 seconds
                if (now - shakeStartTime >= SHAKE_DURATION && !hiddenUnlocksRevealed) {
                    hiddenUnlocksRevealed = true;
                    showHiddenUnlocks();
                }
            } else {
                // Reset if stopped shaking
                if (lastShakeTime > 0 && Date.now() - lastShakeTime > 500) {
                    shakeStartTime = null;
                }
            }
        }

        // Initialize shake detection
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', handleShake);
        }

        function showHiddenUnlocks() {
            const list = document.getElementById('achievementsList');
            
            // Add separator
            const separator = document.createElement('div');
            separator.style.cssText = 'margin: 30px 0; padding: 20px; text-align: center; border-top: 2px solid rgba(255, 215, 0, 0.3); border-bottom: 2px solid rgba(255, 215, 0, 0.3);';
            separator.innerHTML = '<h3 style="color: #FFD700; font-size: 1.3em; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); animation: shimmer 2s infinite;">‚ú® HIDDEN UNLOCKS ‚ú®</h3>';
            list.appendChild(separator);
            
            // Add hidden unlocks
            Object.values(HIDDEN_UNLOCKS).forEach(unlock => {
                const unlocked = unlock.unlockCondition();
                const div = document.createElement('div');
                div.style.cssText = `
                    padding: 20px; 
                    margin: 15px 0; 
                    background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.1)); 
                    border-radius: 12px; 
                    border: 2px solid rgba(255, 215, 0, 0.5);
                    box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
                    animation: shimmer 3s infinite;
                `;
                div.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="font-size: 2.5em; filter: drop-shadow(0 0 5px gold);">${unlocked ? '‚≠ê' : 'üîí'}</span>
                        <div style="flex: 1;">
                            <h3 style="color: #FFD700; margin: 0; font-size: 1.2em; text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);">${unlock.name}</h3>
                            <p style="color: #FFF; margin: 8px 0; font-size: 1em; font-weight: 500;">${unlock.desc}</p>
                            <p style="color: ${unlocked ? '#FFD700' : '#AAA'}; margin: 5px 0; font-size: 0.9em; font-style: italic;">${unlocked ? '‚úì Unlocked: ' + unlock.reward : 'üîí Keep Playing!'}</p>
                        </div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        // Achievements viewing
        function showAchievementsPage() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';
            hiddenUnlocksRevealed = false; // Reset hidden unlocks visibility
            
            // Group achievements by category
            const categories = {
                survival: { name: '‚è±Ô∏è SURVIVAL TIME', color: '#4CAF50', achievements: [] },
                collection: { name: 'üî• GOLDEN FLAME COLLECTION', color: '#FF6600', achievements: [] },
                aerial: { name: '‚úàÔ∏è AERIAL ACROBATICS', color: '#4FC3F7', achievements: [] },
                cruise: { name: 'üõû CRUISE CONTROL', color: '#FFC107', achievements: [] },
                mastery: { name: 'üëë MASTERY MARKS', color: '#9C27B0', achievements: [] }
            };
            
            // Organize achievements into categories
            Object.values(ACHIEVEMENTS).forEach(achievement => {
                const category = achievement.category || 'mastery';
                if (categories[category]) {
                    categories[category].achievements.push(achievement);
                }
            });
            
            // Render each category
            Object.values(categories).forEach(category => {
                if (category.achievements.length === 0) return;
                
                // Category header with horizontal line
                const header = document.createElement('div');
                header.style.cssText = `
                    margin: 30px 0 20px 0;
                    text-align: center;
                    position: relative;
                `;
                header.innerHTML = `
                    <div style="
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        gap: 15px;
                    ">
                        <div style="
                            height: 2px;
                            width: 25%;
                            background: linear-gradient(to right, transparent, ${category.color});
                        "></div>
                        <h2 style="
                            color: ${category.color};
                            font-size: 1.3em;
                            margin: 0;
                            text-shadow: 0 0 10px ${category.color}80;
                            white-space: nowrap;
                        ">${category.name}</h2>
                        <div style="
                            height: 2px;
                            width: 25%;
                            background: linear-gradient(to left, transparent, ${category.color});
                        "></div>
                    </div>
                `;
                list.appendChild(header);
                
                // Render achievements in this category
                category.achievements.forEach(achievement => {
                    const unlocked = achievementsProgress.unlocked.includes(achievement.id);
                    const div = document.createElement('div');
                    div.style.cssText = 'padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 4px solid ' + (unlocked ? category.color : '#444');
                    div.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 2em;">${unlocked ? 'üèÜ' : 'üîí'}</span>
                            <div style="flex: 1;">
                                <h3 style="color: ${unlocked ? category.color : '#888'}; margin: 0; font-size: 1.1em;">${achievement.name}</h3>
                                <p style="color: #ccc; margin: 5px 0; font-size: 0.9em;">${achievement.desc}</p>
                                <p style="color: ${unlocked ? category.color : '#666'}; margin: 5px 0; font-size: 0.85em; font-style: italic;">${unlocked ? '‚úì Unlocked: ' + achievement.reward : 'üîí Locked'}</p>
                            </div>
                        </div>
                    `;
                    list.appendChild(div);
                });
            });
            
            // Update lifetime flames counter
            const lifetimeFlames = achievementsProgress.flamesLifetime || 0;
            document.getElementById('lifetimeFlamesCounter').textContent = `üî• ${lifetimeFlames}`;
            
            document.getElementById('achievementsPage').classList.add('active');
        }

        document.getElementById('viewAchievementsOption').addEventListener('click', () => {
            achievementsOpenedFrom = 'unlockables';
            document.getElementById('unlockablesMenu').classList.remove('active');
            showAchievementsPage();
        });

        document.getElementById('tutorialViewAchievements').addEventListener('click', () => {
            achievementsOpenedFrom = 'tutorial';
            document.getElementById('tutorialModal').classList.remove('active');
            showAchievementsPage();
        });

        document.getElementById('closeAchievementsBtn').addEventListener('click', () => {
            document.getElementById('achievementsPage').classList.remove('active');
            
            // Restore the previous view
            if (achievementsOpenedFrom === 'tutorial') {
                document.getElementById('tutorialModal').classList.add('active');
            } else if (achievementsOpenedFrom === 'unlockables') {
                document.getElementById('unlockablesMenu').classList.add('active');
            }
            achievementsOpenedFrom = null;
        });

        document.getElementById('tutorialNext').addEventListener('click', () => {
            if (currentTutorialSlide < tutorialSlides.length - 1) {
                currentTutorialSlide++;
                updateTutorialSlide();
            } else {
                closeTutorial();
            }
        });

        document.getElementById('tutorialPrev').addEventListener('click', () => {
            if (currentTutorialSlide > 0) {
                currentTutorialSlide--;
                updateTutorialSlide();
            }
        });

        document.getElementById('tutorialSkip').addEventListener('click', closeTutorial);

        tutorialDots.forEach(dot => {
            dot.addEventListener('click', () => {
                currentTutorialSlide = parseInt(dot.getAttribute('data-dot'));
                updateTutorialSlide();
            });
        });

        // ============================================================
        // SETTINGS MENU
        // ============================================================
        let gameWasPausedBeforeSettings = false;
        
        document.getElementById('settingsBtn').addEventListener('click', () => {
            if (gameState === 'playing') {
                // Pause the game without showing pause overlay
                pauseGame(true);
                gameWasPausedBeforeSettings = false;
            } else if (gameState === 'paused') {
                gameWasPausedBeforeSettings = true;
            }
            updateMusicText(); // Update music selection text when opening settings
            updateThemeText(); // Update theme selection text when opening settings
            renderSkinGrid(); // Update skin grid to reflect unlocked skins
            document.getElementById('settingsMenu').classList.add('active');
        });

        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            document.getElementById('settingsMenu').classList.remove('active');
            
            // If game is not started, return to splash screen
            if (gameState === 'menu') {
                splashScreen.classList.remove('hidden');
                showSplashButtons(false); // Show buttons without animation
                updateLeaderboardButtonState();
            }
            // Resume game if it wasn't already paused before opening settings
            else if (!gameWasPausedBeforeSettings && gameState === 'paused') {
                resumeGame();
            }
        });

        document.getElementById('viewTutorialOption').addEventListener('click', () => {
            document.getElementById('settingsMenu').classList.remove('active');
            document.getElementById('pauseOverlay').classList.remove('active');
            currentTutorialSlide = 0;
            updateTutorialSlide();
            document.getElementById('tutorialModal').classList.add('active');
        });

        document.getElementById('viewUnlockablesOption').addEventListener('click', () => {
            document.getElementById('settingsMenu').classList.remove('active');
            updateMusicText();
            updateThemeText();
            renderSkinGrid();
            document.getElementById('unlockablesMenu').classList.add('active');
        });

        document.getElementById('closeUnlockablesBtn').addEventListener('click', () => {
            document.getElementById('unlockablesMenu').classList.remove('active');
            document.getElementById('settingsMenu').classList.add('active');
        });

        document.getElementById('toggleAudioOption').addEventListener('click', toggleAudio);
        
        document.getElementById('toggleHandednessOption').addEventListener('click', toggleHandedness);
        
        document.getElementById('selectMusicOption').addEventListener('click', cycleBackgroundMusic);
        
        document.getElementById('selectThemeOption').addEventListener('click', cycleTheme);

        // ============================================================
        // DEVELOPER ANALYTICS (Secret Triple-Tap Gesture)
        // ============================================================
        let settingsTapCount = 0;
        let settingsTapTimer = null;
        
        document.getElementById('settingsTitle').addEventListener('click', () => {
            settingsTapCount++;
            
            if (settingsTapCount === 1) {
                settingsTapTimer = setTimeout(() => {
                    settingsTapCount = 0;
                }, 1000); // Reset after 1 second
            }
            
            if (settingsTapCount === 3) {
                clearTimeout(settingsTapTimer);
                settingsTapCount = 0;
                openAnalyticsDashboard();
            }
        });
        
        function gatherAnalyticsData() {
            const currentSessionTime = gameState === 'playing' ? (Date.now() - gameStartTime + bonusTime) / 1000 : 0;
            const data = {
                timestamp: new Date().toISOString(),
                session: {
                    currentGameState: gameState,
                    currentScore: score,
                    currentCombo: combo,
                    survivalTime: currentSessionTime
                },
                localStorage: {
                    highScore: localStorage.getItem('scratchKingHighScore') || 0,
                    totalGamesPlayed: (musicProgress.gamesPlayed || 0),
                    achievements: JSON.parse(localStorage.getItem('scratchKingAchievements') || '{}'),
                    music: JSON.parse(localStorage.getItem('scratchKingMusic') || '{}'),
                    leaderboard: JSON.parse(localStorage.getItem('scratchKingLeaderboard') || '[]'),
                    feltColor: localStorage.getItem('scratchKingFeltColor') || 'default',
                    cueBallSkin: localStorage.getItem('cueBallSkin') || 'default',
                    handedness: localStorage.getItem('scratchKingHandedness') || 'right-handed',
                    audioMuted: localStorage.getItem('scratchKingAudioMuted') === 'true',
                    consentGiven: localStorage.getItem('scratchKingConsentGiven') === 'true',
                    hiddenRevealed: localStorage.getItem('scratchKingHiddenUnlocks') === 'true'
                },
                computed: {
                    totalAchievements: achievementsProgress.unlocked?.length || 0,
                    totalPossibleAchievements: Object.keys(ACHIEVEMENTS).length,
                    achievementCompletionRate: ((achievementsProgress.unlocked?.length || 0) / Object.keys(ACHIEVEMENTS).length * 100).toFixed(1) + '%',
                    unlockedSkins: Object.values(CUE_BALL_SKINS).filter(skin => isSkinUnlocked(skin.id)).length,
                    totalSkins: Object.values(CUE_BALL_SKINS).length,
                    unlockedMusic: musicProgress.unlockedTracks?.length || 1,
                    totalMusic: Object.keys(BACKGROUND_TRACKS).length,
                    lifetimeFlames: achievementsProgress.lifetimeFlames || 0,
                    averageLeaderboardScore: calculateAverageScore(),
                    topLeaderboardScore: leaderboard[0]?.score || 0
                },
                powerUps: {
                    totalCollected: {
                        flames: achievementsProgress.lifetimeFlames || 0
                    }
                }
            };
            
            return data;
        }
        
        function calculateAverageScore() {
            if (leaderboard.length === 0) return 0;
            const total = leaderboard.reduce((sum, entry) => sum + entry.score, 0);
            return Math.floor(total / leaderboard.length);
        }
        
        function openAnalyticsDashboard() {
            console.log('üîì Developer Analytics unlocked via triple-tap!');
            const analytics = gatherAnalyticsData();
            
            // Fetch backend aggregated data
            fetch('/api/analytics/aggregate')
                .then(res => res.json())
                .then(aggregateData => {
                    displayAnalytics(analytics, aggregateData);
                })
                .catch(err => {
                    console.error('Failed to fetch aggregate analytics:', err);
                    displayAnalytics(analytics, null);
                });
            
            document.getElementById('settingsMenu').classList.remove('active');
            document.getElementById('analyticsPanel').style.display = 'flex';
        }
        
        function displayAnalytics(data, aggregateData) {
            const container = document.getElementById('analyticsContent');
            
            let html = '<pre style="margin: 0; line-height: 1.6;">';
            html += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            html += '        SCRATCH KING ANALYTICS\n';
            html += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
            
            html += 'üìÖ TIMESTAMP: ' + data.timestamp + '\n\n';
            
            html += 'üéÆ CURRENT SESSION\n';
            html += '  State: ' + data.session.currentGameState + '\n';
            html += '  Score: ' + Math.floor(data.session.currentScore) + '\n';
            html += '  Combo: ' + data.session.currentCombo + 'x\n';
            html += '  Survival: ' + data.session.survivalTime.toFixed(1) + 's\n\n';
            
            html += 'üèÜ PLAYER STATISTICS\n';
            html += '  High Score: ' + data.localStorage.highScore + '\n';
            html += '  Games Played: ' + data.computed.totalAchievements + '\n';
            html += '  Achievements: ' + data.computed.totalAchievements + '/' + data.computed.totalPossibleAchievements + ' (' + data.computed.achievementCompletionRate + ')\n';
            html += '  Lifetime Flames: ' + data.computed.lifetimeFlames + ' üî•\n';
            html += '  Skins Unlocked: ' + data.computed.unlockedSkins + '/' + data.computed.totalSkins + '\n';
            html += '  Music Unlocked: ' + data.computed.unlockedMusic + '/' + data.computed.totalMusic + '\n\n';
            
            html += 'üìä LEADERBOARD\n';
            html += '  Top Score: ' + data.computed.topLeaderboardScore + '\n';
            html += '  Average Score: ' + data.computed.averageLeaderboardScore + '\n';
            html += '  Total Entries: ' + data.localStorage.leaderboard.length + '\n\n';
            
            html += '‚öôÔ∏è PREFERENCES\n';
            html += '  Handedness: ' + data.localStorage.handedness + '\n';
            html += '  Audio: ' + (data.localStorage.audioMuted ? 'Muted' : 'Enabled') + '\n';
            html += '  Cue Ball Skin: ' + data.localStorage.cueBallSkin + '\n';
            html += '  Felt Color: ' + data.localStorage.feltColor + '\n';
            html += '  Current Music: ' + data.localStorage.music.currentTrack + '\n\n';
            
            html += 'üîê PRIVACY & SECRETS\n';
            html += '  Consent Given: ' + (data.localStorage.consentGiven ? 'Yes' : 'No') + '\n';
            html += '  Hidden Unlocks Revealed: ' + (data.localStorage.hiddenRevealed ? 'Yes' : 'No') + '\n\n';
            
            html += 'üèÖ ACHIEVEMENTS UNLOCKED\n';
            const unlockedAchievements = data.localStorage.achievements.unlocked || [];
            if (unlockedAchievements.length > 0) {
                unlockedAchievements.forEach(id => {
                    const achievement = ACHIEVEMENTS[id];
                    if (achievement) {
                        html += '  ‚úì ' + achievement.name + '\n';
                    }
                });
            } else {
                html += '  (None yet)\n';
            }
            
            // Add aggregate user data if available
            if (aggregateData && aggregateData.aggregate) {
                const agg = aggregateData.aggregate;
                html += '\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
                html += '       ALL PLAYERS AGGREGATE DATA\n';
                html += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
                
                html += 'üìà OVERALL STATISTICS\n';
                html += '  Total Player Sessions: ' + agg.totalSessions + '\n';
                html += '  Network High Score: ' + agg.avgHighScore + '\n';
                html += '  Avg Games/Player: ' + agg.avgGamesPlayed + '\n';
                html += '  Avg Achievements: ' + agg.avgAchievements + '\n';
                html += '  Total Flames Collected: ' + agg.totalFlamesCollected + ' üî•\n';
                html += '  Avg Skins Unlocked: ' + agg.avgSkinsUnlocked + '\n\n';
                
                html += 'üì± DEVICE BREAKDOWN\n';
                html += '  Mobile: ' + agg.deviceBreakdown.mobile + ' sessions\n';
                html += '  Desktop: ' + agg.deviceBreakdown.desktop + ' sessions\n\n';
                
                html += 'üåê BROWSER BREAKDOWN\n';
                html += '  Chrome: ' + agg.browserBreakdown.chrome + '\n';
                html += '  Firefox: ' + agg.browserBreakdown.firefox + '\n';
                html += '  Safari: ' + agg.browserBreakdown.safari + '\n';
                html += '  Edge: ' + agg.browserBreakdown.edge + '\n';
                html += '  Other: ' + agg.browserBreakdown.other + '\n\n';
                
                html += 'ü§ö HANDEDNESS PREFERENCE\n';
                html += '  Right-Handed: ' + agg.handednessPreference.rightHanded + '\n';
                html += '  Left-Handed: ' + agg.handednessPreference.leftHanded + '\n\n';
                
                html += 'üîä AUDIO PREFERENCE\n';
                html += '  Enabled: ' + agg.audioPreference.enabled + '\n';
                html += '  Muted: ' + agg.audioPreference.muted + '\n\n';
                
                if (agg.topSkins && agg.topSkins.length > 0) {
                    html += '‚≠ê MOST POPULAR SKINS\n';
                    agg.topSkins.forEach((item, idx) => {
                        html += '  ' + (idx + 1) + '. ' + (item[0] || 'default') + ': ' + item[1] + ' players\n';
                    });
                    html += '\n';
                }
                
                if (agg.topMusic && agg.topMusic.length > 0) {
                    html += 'üéµ MOST POPULAR MUSIC\n';
                    agg.topMusic.forEach((item, idx) => {
                        html += '  ' + (idx + 1) + '. ' + (item[0] || 'classic') + ': ' + item[1] + ' players\n';
                    });
                    html += '\n';
                }
            }
            
            html += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
            html += '</pre>';
            
            container.innerHTML = html;
        }
        
        document.getElementById('closeAnalyticsBtn').addEventListener('click', () => {
            document.getElementById('analyticsPanel').style.display = 'none';
            document.getElementById('settingsMenu').classList.add('active');
        });
        
        document.getElementById('exportAnalyticsBtn').addEventListener('click', () => {
            const analytics = gatherAnalyticsData();
            const jsonString = JSON.stringify(analytics, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                const btn = document.getElementById('exportAnalyticsBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        });

        // ============================================================
        // PAUSE SYSTEM
        // ============================================================
        function updatePauseButton() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (gameState === 'paused') {
                pauseBtn.textContent = '‚ñ∂Ô∏è';
            } else {
                pauseBtn.textContent = '‚è∏';
            }
        }

        function pauseGame(hideOverlay = false) {
            if (gameState !== 'playing') return;
            gameState = 'paused';
            if (!hideOverlay) {
                document.getElementById('pauseOverlay').classList.add('active');
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            updatePauseButton();
        }

        function resumeGame() {
            if (gameState !== 'paused') return;
            gameState = 'playing';
            document.getElementById('pauseOverlay').classList.remove('active');
            gameLoop();
            updatePauseButton();
        }

        function togglePause() {
            if (gameState === 'playing') {
                pauseGame();
            } else if (gameState === 'paused') {
                resumeGame();
            }
        }

        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('resumeBtn').addEventListener('click', resumeGame);
        document.getElementById('pauseSettingsBtn').addEventListener('click', () => {
            document.getElementById('pauseOverlay').classList.remove('active');
            updateMusicText();
            updateThemeText();
            renderSkinGrid();
            document.getElementById('settingsMenu').classList.add('active');
            gameWasPausedBeforeSettings = true; // Game is already paused
        });
        document.getElementById('pauseMenuBtn').addEventListener('click', () => {
            document.getElementById('pauseOverlay').classList.remove('active');
            returnToMenu();
        });

        // Keyboard pause (Escape key)
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    resumeGame();
                }
            }
        });

        // Stop game over voice when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && sounds.gameOverVoice) {
                sounds.gameOverVoice.pause();
            }
        });

        // ============================================================
        // SCREENSHOT FEATURE
        // ============================================================
        document.getElementById('shareScoreBtn').addEventListener('click', () => {
            // Load and draw header logo at top
            const logo = new Image();
            logo.src = 'https://prometheangamescom.wordpress.com/wp-content/uploads/2025/11/header-logov2-cropped.png';
            logo.onload = () => {
                // Calculate required canvas height
                const canvasWidth = 600;
                const logoHeight = (logo.height / logo.width) * canvasWidth;
                const tableHeight = 50 * 7; // 7 rows at 50px each
                const canvasHeight = 20 + logoHeight + 40 + 20 + tableHeight + 40; // padding + logo + gap + padding + table + bottom padding
                
                // Create a temporary canvas
                const shareCanvas = document.createElement('canvas');
                shareCanvas.width = canvasWidth;
                shareCanvas.height = canvasHeight;
                const shareCtx = shareCanvas.getContext('2d');

                // Forest green background (#014421)
                shareCtx.fillStyle = '#014421';
                shareCtx.fillRect(0, 0, shareCanvas.width, shareCanvas.height);
                
                // Draw logo at top, fit width with proper aspect ratio
                shareCtx.drawImage(logo, 0, 20, shareCanvas.width, logoHeight);
                
                // Continue drawing rest of content
                drawGameOverStats(shareCtx, shareCanvas, logoHeight + 40);
            };
            
            function drawGameOverStats(ctx, canvas, startY) {
                // Get the stats values from the game over screen
                const finalScore = document.getElementById('finalScore').textContent;
                const finalTime = document.getElementById('finalTime').textContent;
                const finalFlames = document.getElementById('finalFlames').textContent;
                const finalNearMisses = document.getElementById('finalNearMisses').textContent;
                const finalJumpedBalls = document.getElementById('finalJumpedBalls').textContent;
                const finalAirTime = document.getElementById('finalAirTime').textContent;
                const finalDistance = document.getElementById('finalDistance').textContent;

                // Stats table
                const statsStartY = startY + 20;
                const tableWidth = 500;
                const tableX = (canvas.width - tableWidth) / 2;
                const rowHeight = 50;
                const stats = [
                    { label: 'SCORE', value: finalScore },
                    { label: 'TIME', value: finalTime },
                    { label: 'FLAMES', value: finalFlames },
                    { label: 'NEAR MISSES', value: finalNearMisses },
                    { label: 'JUMPED BALLS', value: finalJumpedBalls },
                    { label: 'AIR TIME', value: finalAirTime },
                    { label: 'DISTANCE', value: finalDistance }
                ];

                // Draw table background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(tableX, statsStartY, tableWidth, rowHeight * stats.length);
                
                // Draw table border
                ctx.strokeStyle = '#d11111';
                ctx.lineWidth = 3;
                ctx.strokeRect(tableX, statsStartY, tableWidth, rowHeight * stats.length);

                // Draw each row
                stats.forEach((stat, index) => {
                    const rowY = statsStartY + (index * rowHeight);
                    
                    // Draw row separator (except first row)
                    if (index > 0) {
                        ctx.strokeStyle = 'rgba(209, 17, 17, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(tableX, rowY);
                        ctx.lineTo(tableX + tableWidth, rowY);
                        ctx.stroke();
                    }
                    
                    // Draw label (left aligned)
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(stat.label, tableX + 20, rowY + 32);
                    
                    // Draw value (right aligned)
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(stat.value, tableX + tableWidth - 20, rowY + 32);
                });

                // Download the image
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scratch-king-score-${finalScore}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }
        });

        // ============================================================
        // CONSENT & PRIVACY
        // ============================================================
        const consentToast = document.getElementById('consentToast');
        const consentCheckbox = document.getElementById('consentCheckbox');
        const consentAcceptBtn = document.getElementById('consentAcceptBtn');
        const privacyModal = document.getElementById('privacyModal');
        const privacyPolicyLink = document.getElementById('privacyPolicyLink');
        const closePrivacyBtn = document.getElementById('closePrivacyBtn');

        // Check if user has already consented
        const analyticsConsent = localStorage.getItem('scratchKingAnalyticsConsent');

        // Analytics object to track user data
        // When user consents, all three categories (gameplay, technical, engagement) are enabled together
        const analytics = {
            // All categories enabled/disabled together based on consent
            gameplay: analyticsConsent === 'true',
            technical: analyticsConsent === 'true',
            engagement: analyticsConsent === 'true',
            
            // Update all categories when consent changes
            setConsent(enabled) {
                this.gameplay = enabled;
                this.technical = enabled;
                this.engagement = enabled;
            },
            
            // Track gameplay event (scores, achievements, session duration)
            trackGameplay(eventType, data) {
                if (!this.gameplay) return;
                console.log('[Analytics - Gameplay]', eventType, data);
                // In production, send to analytics service
                // Example: fetch('/api/analytics', { method: 'POST', body: JSON.stringify({ category: 'gameplay', event: eventType, data }) });
            },
            
            // Track technical data (device type, screen resolution, browser)
            trackTechnical(eventType, data) {
                if (!this.technical) return;
                const techData = {
                    deviceType: /Mobile|Android|iPhone|iPad/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
                    screenWidth: window.innerWidth,
                    screenHeight: window.innerHeight,
                    browser: navigator.userAgent,
                    ...data
                };
                console.log('[Analytics - Technical]', eventType, techData);
                // In production, send to analytics service
            },
            
            // Track engagement event (daily active, feature usage, retention)
            trackEngagement(eventType, data) {
                if (!this.engagement) return;
                console.log('[Analytics - Engagement]', eventType, data);
                // In production, send to analytics service
            }
        };

        // Enable/disable consent button based on checkbox
        consentCheckbox.addEventListener('change', () => {
            consentAcceptBtn.disabled = !consentCheckbox.checked;
        });

        // Handle consent acceptance
        consentAcceptBtn.addEventListener('click', () => {
            const consent = consentCheckbox.checked;
            localStorage.setItem('scratchKingAnalyticsConsent', consent ? 'true' : 'false');
            
            // Update all analytics categories together
            analytics.setConsent(consent);
            
            // Hide the consent toast with animation
            consentToast.classList.remove('show');
            
            if (consent) {
                console.log('‚úÖ Analytics enabled (Gameplay, Technical, Engagement) - Thank you for helping us improve!');
                analytics.trackEngagement('consent_given', { 
                    timestamp: new Date().toISOString(),
                    categories: ['gameplay', 'technical', 'engagement']
                });
            } else {
                console.log('üîí Analytics disabled - Your privacy is protected');
            }
        });

        // Show consent toast if user hasn't responded yet
        function checkConsentStatus() {
            if (analyticsConsent === null) {
                // Show toast after 2 seconds
                setTimeout(() => {
                    consentToast.classList.add('show');
                }, 2000);
            }
        }

        // Privacy policy link click handler
        privacyPolicyLink.addEventListener('click', () => {
            privacyModal.classList.add('active');
        });

        // Close privacy modal
        closePrivacyBtn.addEventListener('click', () => {
            privacyModal.classList.remove('active');
        });

        // Close modal if clicking outside content
        privacyModal.addEventListener('click', (e) => {
            if (e.target === privacyModal) {
                privacyModal.classList.remove('active');
            }
        });

        // Example analytics tracking calls (integrate throughout game)
        // You can call these wherever appropriate in the game code:
        /*
        analytics.trackGameplay('game_started', { timestamp: new Date().toISOString() });
        analytics.trackGameplay('game_ended', { score: finalScore, time: runTime, flames: flamesCollected });
        analytics.trackGameplay('achievement_unlocked', { achievement: achievementName });
        analytics.trackEngagement('session_start', { timestamp: new Date().toISOString() });
        analytics.trackTechnical('game_loaded', { loadTime: performance.now() });
        */

        // ============================================================
        // INITIALIZATION
        // ============================================================
        applyFeltColor(); // Apply the felt color on page load
        applyHandedness(); // Apply the handedness preference on page load
        checkMusicUnlocks(); // Check if any music tracks should be unlocked
        updateMusicText(); // Update the music selection text in settings
        updateThemeText(); // Update the theme selection text in settings
        setupCarouselNavigation(); // Set up skin carousel navigation
        renderSkinGrid(); // Initialize skin carousel with current unlocks
        updateLeaderboardButtonState(); // Enable/disable leaderboard button based on scores
        checkConsentStatus(); // Show consent toast if user hasn't responded
        console.log('Scratch King initialized');
        console.log('Use arrow keys or on-screen buttons to move between lanes');
        console.log('Swipe left/right on mobile to change lanes');
    </script>
</body>
</html>
